
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Infinite Moduli, Roots of Unity, and Coprime Density</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Palatino Linotype', 'Book Antiqua', Palatino, serif;
            background: #fafafa;
            color: #1a1a1a;
            line-height: 1.6;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            padding: 40px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        header {
            text-align: center;
            margin-bottom: 50px;
            border-bottom: 2px solid #333;
            padding-bottom: 30px;
        }
        
        h1 {
            font-size: 2.2em;
            font-weight: 600;
            margin-bottom: 15px;
            color: #1a1a1a;
        }
        
        .subtitle {
            font-size: 1.3em;
            color: #555;
            font-style: italic;
            margin-bottom: 20px;
        }
        
        .author {
            font-size: 1.1em;
            color: #333;
            margin-top: 20px;
        }
        
        h2 {
            font-size: 1.6em;
            margin-top: 40px;
            margin-bottom: 20px;
            color: #2c3e50;
            border-bottom: 1px solid #ddd;
            padding-bottom: 10px;
        }
        
        h3 {
            font-size: 1.3em;
            margin-top: 30px;
            margin-bottom: 15px;
            color: #34495e;
        }
        
        .abstract {
            background: #f8f9fa;
            padding: 25px;
            margin: 30px 0;
            border-left: 4px solid #3498db;
            font-size: 1.05em;
        }
        
        .theorem {
            background: #fff9e6;
            padding: 20px;
            margin: 20px 0;
            border-left: 4px solid #f39c12;
        }
        
        .theorem-title {
            font-weight: 700;
            color: #d68910;
            margin-bottom: 10px;
        }
        
        .canvas-container {
            margin: 30px 0;
            text-align: center;
        }
        
        canvas {
            border: 1px solid #ddd;
            background: white;
            display: block;
            margin: 20px auto;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        .controls {
            background: #f8f9fa;
            padding: 25px;
            margin: 20px 0;
            border-radius: 5px;
            border: 1px solid #dee2e6;
        }
        
        .control-group {
            margin: 15px 0;
        }
        
        label {
            display: inline-block;
            width: 180px;
            font-weight: 600;
            color: #495057;
        }
        
        input[type="range"] {
            width: 300px;
            vertical-align: middle;
        }
        
        input[type="number"] {
            width: 80px;
            padding: 5px;
            border: 1px solid #ced4da;
            border-radius: 3px;
        }
        
        button {
            background: #3498db;
            color: white;
            border: none;
            padding: 10px 20px;
            margin: 5px;
            cursor: pointer;
            font-size: 1em;
            border-radius: 4px;
            transition: background 0.3s;
        }
        
        button:hover {
            background: #2980b9;
        }
        
        button:active {
            background: #21618c;
        }
        
        .export-buttons {
            text-align: center;
            margin: 20px 0;
        }
        
        .stats-panel {
            background: #e8f4f8;
            padding: 20px;
            margin: 20px 0;
            border-radius: 5px;
            border: 1px solid #b8dae5;
        }
        
        .stat-item {
            margin: 10px 0;
            font-size: 1.05em;
        }
        
        .stat-label {
            font-weight: 600;
            color: #2c3e50;
        }
        
        .stat-value {
            color: #2980b9;
            font-family: 'Courier New', monospace;
        }
        
        .math {
            font-style: italic;
            font-family: 'Times New Roman', serif;
        }
        
        .section-content {
            margin: 20px 0;
            text-align: justify;
        }
        
        .interpretation {
            background: #f0f7ff;
            padding: 20px;
            margin: 20px 0;
            border-left: 4px solid #5dade2;
        }
        
        .value-display {
            display: inline-block;
            min-width: 60px;
            text-align: center;
            font-weight: 600;
            color: #2980b9;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Infinite Moduli, Roots of Unity, and the Density of Coprime Channels</h1>
            <div class="subtitle">An Interactive Exploration of Classical Results in Analytic Number Theory</div>
            <div class="author">by Wessen Getachew</div>
        </header>

        <div class="abstract">
            <strong>Abstract:</strong> This interactive document explores the classical connection between rational points on the unit circle arising from roots of unity, the density of coprime integer pairs, and the asymptotic behavior of Farey sequences. We demonstrate that while the set of all rational angles is dense on the unit circle, the subset corresponding to reduced fractions (coprime numerator and denominator) has natural density 3/π². The global average of φ(m)/m over all moduli converges to 6/π², reconciling the fact that prime moduli individually approach density 1 while having measure zero in the integers.
        </div>

        <h2>1. Unit Circle and Rational Angles</h2>
        <div class="section-content">
            <p>For each modulus <span class="math">m</span>, the reduced residue system Φ(<span class="math">m</span>) = {<span class="math">r</span> : gcd(<span class="math">r</span>, <span class="math">m</span>) = 1, 0 ≤ <span class="math">r</span> < <span class="math">m</span>} maps to points on the unit circle via <span class="math">r</span> → exp(2π<span class="math">i r</span>/<span class="math">m</span>). The visualization below shows these points for varying moduli.</p>
        </div>

        <div class="controls">
            <div class="control-group">
                <label>Maximum Modulus:</label>
                <input type="range" id="maxModulus" min="1" max="50" value="12" oninput="updateModulusDisplay(this.value); renderAll()">
                <span class="value-display" id="maxModulusValue">12</span>
            </div>
            <div class="control-group">
                <label>Show Coprime Only:</label>
                <input type="checkbox" id="coprimeOnly" checked onchange="renderAll()">
            </div>
            <div class="control-group">
                <label>Point Size:</label>
                <input type="range" id="pointSize" min="1" max="8" value="3" oninput="updatePointSizeDisplay(this.value); renderAll()">
                <span class="value-display" id="pointSizeValue">3</span>
            </div>
        </div>

        <div class="canvas-container">
            <canvas id="unitCircleCanvas" width="800" height="800"></canvas>
            <div class="export-buttons">
                <button onclick="exportCanvas('unitCircleCanvas', '4k')">Export as 4K PNG</button>
                <button onclick="exportCircleData()">Export Data as CSV</button>
            </div>
        </div>

        <div class="stats-panel" id="circleStats">
            <h3>Statistics for Unit Circle Visualization</h3>
            <div class="stat-item">
                <span class="stat-label">Total Points Plotted:</span>
                <span class="stat-value" id="totalPoints">0</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Coprime Points:</span>
                <span class="stat-value" id="coprimePoints">0</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Coprime Ratio:</span>
                <span class="stat-value" id="coprimeRatio">0</span>
            </div>
        </div>

        <h2>2. Density of Coprime Pairs</h2>
        <div class="section-content">
            <p>Let <span class="math">A<sub>N</sub></span> = #{(<span class="math">a</span>, <span class="math">b</span>) : 1 ≤ <span class="math">a</span>, <span class="math">b</span> ≤ <span class="math">N</span>, gcd(<span class="math">a</span>, <span class="math">b</span>) = 1} be the count of coprime pairs in an <span class="math">N</span> × <span class="math">N</span> grid.</p>
        </div>

        <div class="theorem">
            <div class="theorem-title">Theorem (Coprime Pair Density):</div>
            lim<sub><span class="math">N</span>→∞</sub> <span class="math">A<sub>N</sub></span> / <span class="math">N</span>² = 6/π² ≈ 0.6079
        </div>

        <div class="controls">
            <div class="control-group">
                <label>Grid Size N:</label>
                <input type="range" id="gridSize" min="10" max="200" value="50" step="10" oninput="updateGridSizeDisplay(this.value); renderCoprimePairs()">
                <span class="value-display" id="gridSizeValue">50</span>
            </div>
        </div>

        <div class="canvas-container">
            <canvas id="coprimePairsCanvas" width="800" height="800"></canvas>
            <div class="export-buttons">
                <button onclick="exportCanvas('coprimePairsCanvas', '4k')">Export as 4K PNG</button>
                <button onclick="exportCoprimePairsData()">Export Data as CSV</button>
            </div>
        </div>

        <div class="stats-panel" id="pairsStats">
            <h3>Coprime Pairs Statistics</h3>
            <div class="stat-item">
                <span class="stat-label">Grid Size (N):</span>
                <span class="stat-value" id="pairsN">0</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Total Pairs (N²):</span>
                <span class="stat-value" id="totalPairs">0</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Coprime Pairs (A<sub>N</sub>):</span>
                <span class="stat-value" id="coprimePairsCount">0</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Ratio A<sub>N</sub>/N²:</span>
                <span class="stat-value" id="pairsRatio">0</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Theoretical Limit (6/π²):</span>
                <span class="stat-value">0.607927</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Error from Limit:</span>
                <span class="stat-value" id="pairsError">0</span>
            </div>
        </div>

        <h2>3. Average φ(m)/m Over All Moduli</h2>
        <div class="section-content">
            <p>For each modulus <span class="math">m</span>, the ratio φ(<span class="math">m</span>)/<span class="math">m</span> represents the fraction of residues coprime to <span class="math">m</span>. The average of these ratios converges to the same constant 6/π².</p>
        </div>

        <div class="theorem">
            <div class="theorem-title">Theorem (Average Totient Ratio):</div>
            lim<sub><span class="math">N</span>→∞</sub> (1/<span class="math">N</span>) Σ<sub><span class="math">m</span>=1</sub><sup><span class="math">N</span></sup> φ(<span class="math">m</span>)/<span class="math">m</span> = 6/π² ≈ 0.6079
        </div>

        <div class="controls">
            <div class="control-group">
                <label>Maximum Modulus:</label>
                <input type="range" id="phiMaxModulus" min="10" max="500" value="100" step="10" oninput="updatePhiMaxDisplay(this.value); renderPhiRatios()">
                <span class="value-display" id="phiMaxValue">100</span>
            </div>
            <div class="control-group">
                <label>Show Primes Only:</label>
                <input type="checkbox" id="primesOnly" onchange="renderPhiRatios()">
            </div>
        </div>

        <div class="canvas-container">
            <canvas id="phiRatiosCanvas" width="1200" height="600"></canvas>
            <div class="export-buttons">
                <button onclick="exportCanvas('phiRatiosCanvas', '4k')">Export as 4K PNG</button>
                <button onclick="exportPhiData()">Export Data as CSV</button>
            </div>
        </div>

        <div class="stats-panel" id="phiStats">
            <h3>Totient Ratio Statistics</h3>
            <div class="stat-item">
                <span class="stat-label">Maximum Modulus:</span>
                <span class="stat-value" id="phiMaxMod">0</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Average φ(m)/m:</span>
                <span class="stat-value" id="avgPhiRatio">0</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Theoretical Limit (6/π²):</span>
                <span class="stat-value">0.607927</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Error from Limit:</span>
                <span class="stat-value" id="phiError">0</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Prime Average (if checked):</span>
                <span class="stat-value" id="primeAvg">N/A</span>
            </div>
        </div>

        <h2>4. Convergence Visualization</h2>
        <div class="section-content">
            <p>This chart shows how the running average of φ(<span class="math">m</span>)/<span class="math">m</span> converges to 6/π² as we increase the maximum modulus. The horizontal line represents the theoretical limit.</p>
        </div>

        <div class="canvas-container">
            <canvas id="convergenceCanvas" width="1200" height="600"></canvas>
            <div class="export-buttons">
                <button onclick="exportCanvas('convergenceCanvas', '4k')">Export as 4K PNG</button>
                <button onclick="exportConvergenceData()">Export Data as CSV</button>
            </div>
        </div>

        <h2>5. Interpretation and Key Results</h2>
        <div class="interpretation">
            <h3>Summary of Findings:</h3>
            <ul style="margin-left: 30px; margin-top: 15px;">
                <li style="margin: 10px 0;">The set of all rational angles from roots of unity is dense on the unit circle (Theorem 1).</li>
                <li style="margin: 10px 0;">The natural density of coprime integer pairs is 6/π² ≈ 0.6079 (Theorem 2).</li>
                <li style="margin: 10px 0;">The average value of φ(m)/m over all moduli converges to 6/π² (Theorem 3).</li>
                <li style="margin: 10px 0;">For prime moduli p, φ(p)/p = (p-1)/p → 1, but primes have density zero among integers.</li>
                <li style="margin: 10px 0;">The count of reduced fractions (Farey sequence) with denominator ≤ N grows as (3/π²)N² + O(N log N).</li>
            </ul>
        </div>

        <div class="interpretation" style="margin-top: 30px;">
            <h3>Why There Is No Contradiction:</h3>
            <p style="margin-top: 15px;">
                Prime moduli have φ(p)/p → 1, suggesting "almost all" residues are coprime. However, this does not contradict the global average of 6/π² because:
            </p>
            <ul style="margin-left: 30px; margin-top: 15px;">
                <li style="margin: 10px 0;">Primes become increasingly sparse (density zero by the Prime Number Theorem).</li>
                <li style="margin: 10px 0;">Composite numbers dominate, and highly composite numbers have small φ(m)/m ratios.</li>
                <li style="margin: 10px 0;">The average is weighted by all integers, not just primes.</li>
            </ul>
            <p style="margin-top: 15px;">
                This phenomenon is analogous to how the average value can differ substantially from the behavior of a sparse subsequence.
            </p>
        </div>

        <footer style="margin-top: 50px; padding-top: 30px; border-top: 2px solid #333; text-align: center; color: #666;">
            <p>Interactive Research Document - 2024</p>
            <p>All results are classical theorems in analytic number theory.</p>
            <p style="margin-top: 10px;">Wessen Getachew | <a href="https://github.com/wessengetachew" style="color: #3498db;">GitHub</a> | <a href="https://twitter.com/7dview" style="color: #3498db;">@7dview</a></p>
        </footer>
    </div>

    <script>
        // Mathematical utilities
        function gcd(a, b) {
            a = Math.abs(a);
            b = Math.abs(b);
            while (b !== 0) {
                let t = b;
                b = a % b;
                a = t;
            }
            return a;
        }

        function euler_phi(n) {
            if (n === 1) return 1;
            let result = n;
            let p = 2;
            while (p * p <= n) {
                if (n % p === 0) {
                    while (n % p === 0) n /= p;
                    result -= result / p;
                }
                p++;
            }
            if (n > 1) result -= result / n;
            return Math.round(result);
        }

        function isPrime(n) {
            if (n < 2) return false;
            if (n === 2) return true;
            if (n % 2 === 0) return false;
            for (let i = 3; i * i <= n; i += 2) {
                if (n % i === 0) return false;
            }
            return true;
        }

        const SIX_OVER_PI_SQUARED = 6 / (Math.PI * Math.PI);

        // Display update functions
        function updateModulusDisplay(val) {
            document.getElementById('maxModulusValue').textContent = val;
        }

        function updatePointSizeDisplay(val) {
            document.getElementById('pointSizeValue').textContent = val;
        }

        function updateGridSizeDisplay(val) {
            document.getElementById('gridSizeValue').textContent = val;
        }

        function updatePhiMaxDisplay(val) {
            document.getElementById('phiMaxValue').textContent = val;
        }

        // Render Unit Circle
        function renderUnitCircle() {
            const canvas = document.getElementById('unitCircleCanvas');
            const ctx = canvas.getContext('2d');
            const maxM = parseInt(document.getElementById('maxModulus').value);
            const coprimeOnly = document.getElementById('coprimeOnly').checked;
            const pointSize = parseInt(document.getElementById('pointSize').value);

            const cx = canvas.width / 2;
            const cy = canvas.height / 2;
            const radius = Math.min(cx, cy) - 50;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw circle
            ctx.strokeStyle = '#ccc';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(cx, cy, radius, 0, 2 * Math.PI);
            ctx.stroke();

            // Draw axes
            ctx.strokeStyle = '#ddd';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(cx - radius - 20, cy);
            ctx.lineTo(cx + radius + 20, cy);
            ctx.moveTo(cx, cy - radius - 20);
            ctx.lineTo(cx, cy + radius + 20);
            ctx.stroke();

            let totalPoints = 0;
            let coprimeCount = 0;
            const points = new Set();

            // Plot points
            for (let m = 1; m <= maxM; m++) {
                for (let r = 0; r < m; r++) {
                    const iscoprime = gcd(r, m) === 1;
                    if (coprimeOnly && !iscoprime) continue;

                    totalPoints++;
                    if (iscoprime) coprimeCount++;

                    const angle = 2 * Math.PI * r / m;
                    const x = cx + radius * Math.cos(angle);
                    const y = cy - radius * Math.sin(angle);

                    const key = Math.round(x * 10) + ',' + Math.round(y * 10);
                    if (points.has(key)) continue;
                    points.add(key);

                    ctx.fillStyle = iscoprime ? '#e74c3c' : '#3498db';
                    ctx.beginPath();
                    ctx.arc(x, y, pointSize, 0, 2 * Math.PI);
                    ctx.fill();
                }
            }

            // Update statistics
            document.getElementById('totalPoints').textContent = totalPoints;
            document.getElementById('coprimePoints').textContent = coprimeCount;
            document.getElementById('coprimeRatio').textContent = 
                totalPoints > 0 ? (coprimeCount / totalPoints).toFixed(6) : '0';
        }

        // Render Coprime Pairs Grid
        function renderCoprimePairs() {
            const canvas = document.getElementById('coprimePairsCanvas');
            const ctx = canvas.getContext('2d');
            const N = parseInt(document.getElementById('gridSize').value);

            const cellSize = Math.min(canvas.width, canvas.height) / (N + 2);

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            let coprimeCount = 0;

            for (let a = 1; a <= N; a++) {
                for (let b = 1; b <= N; b++) {
                    const x = a * cellSize;
                    const y = canvas.height - b * cellSize;
                    
                    if (gcd(a, b) === 1) {
                        ctx.fillStyle = '#e74c3c';
                        coprimeCount++;
                    } else {
                        ctx.fillStyle = '#ecf0f1';
                    }
                    
                    ctx.fillRect(x, y, cellSize - 1, cellSize - 1);
                }
            }

            // Draw axes
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(cellSize, 0);
            ctx.lineTo(cellSize, canvas.height - cellSize);
            ctx.lineTo(canvas.width, canvas.height - cellSize);
            ctx.stroke();

            // Labels
            ctx.fillStyle = '#333';
            ctx.font = '14px Arial';
            ctx.fillText('a', canvas.width - 20, canvas.height - cellSize + 20);
            ctx.fillText('b', cellSize - 20, 20);

            // Update statistics
            const totalPairs = N * N;
            const ratio = coprimeCount / totalPairs;
            const error = Math.abs(ratio - SIX_OVER_PI_SQUARED);

            document.getElementById('pairsN').textContent = N;
            document.getElementById('totalPairs').textContent = totalPairs;
            document.getElementById('coprimePairsCount').textContent = coprimeCount;
            document.getElementById('pairsRatio').textContent = ratio.toFixed(6);
            document.getElementById('pairsError').textContent = error.toFixed(6);
        }

        // Render Phi Ratios
        function renderPhiRatios() {
            const canvas = document.getElementById('phiRatiosCanvas');
            const ctx = canvas.getContext('2d');
            const maxM = parseInt(document.getElementById('phiMaxModulus').value);
            const primesOnly = document.getElementById('primesOnly').checked;

            const padding = 60;
            const plotWidth = canvas.width - 2 * padding;
            const plotHeight = canvas.height - 2 * padding;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw axes
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(padding, padding);
            ctx.moveTo(padding, canvas.height - padding);
            ctx.lineTo(canvas.width - padding, canvas.height - padding);
            ctx.stroke();

            // Draw theoretical limit line
            ctx.strokeStyle = '#27ae60';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            const limitY = canvas.height - padding - (SIX_OVER_PI_SQUARED * plotHeight);
            ctx.beginPath();
            ctx.moveTo(padding, limitY);
            ctx.lineTo(canvas.width - padding, limitY);
            ctx.stroke();
            ctx.setLineDash([]);

            // Label for limit
            ctx.fillStyle = '#27ae60';
            ctx.font = '12px Arial';
            ctx.fillText('6/π² ≈ 0.6079', canvas.width - padding + 10, limitY + 5);

            // Plot points
            let sum = 0;
            let count = 0;
            let primeSum = 0;
            let primeCount = 0;

            for (let m = 1; m <= maxM; m++) {
                const isPrimeNum = isPrime(m);
                if (primesOnly && !isPrimeNum) continue;

                const ratio = euler_phi(m) / m;
                const x = padding + (m / maxM) * plotWidth;
                const y = canvas.height - padding - ratio * plotHeight;

                ctx.fillStyle = isPrimeNum ? '#e74c3c' : '#3498db';
                ctx.beginPath();
                ctx.arc(x, y, 2, 0, 2 * Math.PI);
                ctx.fill();

                sum += ratio;
                count++;

                if (isPrimeNum) {
                    primeSum += ratio;
                    primeCount++;
                }
            }

            // Axes labels
            ctx.fillStyle = '#333';
            ctx.font = '14px Arial';
            ctx.fillText('Modulus m', canvas.width / 2, canvas.height - 20);
            ctx.save();
            ctx.translate(20, canvas.height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('φ(m)/m', 0, 0);
            ctx.restore();

            // Update statistics
            const avgRatio = sum / count;
            const error = Math.abs(avgRatio - SIX_OVER_PI_SQUARED);

            document.getElementById('phiMaxMod').textContent = maxM;
            document.getElementById('avgPhiRatio').textContent = avgRatio.toFixed(6);
            document.getElementById('phiError').textContent = error.toFixed(6);
            
            if (primeCount > 0) {
                document.getElementById('primeAvg').textContent = (primeSum / primeCount).toFixed(6);
            } else {
                document.getElementById('primeAvg').textContent = 'N/A';
            }
        }

        // Render Convergence Chart
        function renderConvergence() {
            const canvas = document.getElementById('convergenceCanvas');
            const ctx = canvas.getContext('2d');
            const maxM = 500;

            const padding = 60;
            const plotWidth = canvas.width - 2 * padding;
            const plotHeight = canvas.height - 2 * padding;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw axes
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(padding, padding);
            ctx.moveTo(padding, canvas.height - padding);
            ctx.lineTo(canvas.width - padding, canvas.height - padding);
            ctx.stroke();

            // Draw theoretical limit line
            ctx.strokeStyle = '#27ae60';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            const limitY = canvas.height - padding - (SIX_OVER_PI_SQUARED * plotHeight);
            ctx.beginPath();
            ctx.moveTo(padding, limitY);
            ctx.lineTo(canvas.width - padding, limitY);
            ctx.stroke();
            ctx.setLineDash([]);

            // Calculate running averages
            const runningAvgs = [];
            let sum = 0;
            for (let m = 1; m <= maxM; m++) {
                sum += euler_phi(m) / m;
                runningAvgs.push(sum / m);
            }

            // Plot running average
            ctx.strokeStyle = '#3498db';
            ctx.lineWidth = 2;
            ctx.beginPath();
            for (let i = 0; i < runningAvgs.length; i++) {
                const x = padding + ((i + 1) / maxM) * plotWidth;
                const y = canvas.height - padding - runningAvgs[i] * plotHeight;
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.stroke();

            // Axes labels
            ctx.fillStyle = '#333';
            ctx.font = '14px Arial';
            ctx.fillText('Maximum Modulus N', canvas.width / 2, canvas.height - 20);
            ctx.save();
            ctx.translate(20, canvas.height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('(1/N) Σ φ(m)/m', 0, 0);
            ctx.restore();

            // Legend
            ctx.fillStyle = '#27ae60';
            ctx.fillText('Theoretical: 6/π²', canvas.width - 200, padding + 20);
            ctx.fillStyle = '#3498db';
            ctx.fillText('Running Average', canvas.width - 200, padding + 40);
        }

        // Export functions
        function exportCanvas(canvasId, resolution) {
            const canvas = document.getElementById(canvasId);
            let exportCanvas, exportCtx;

            if (resolution === '4k') {
                exportCanvas = document.createElement('canvas');
                exportCanvas.width = 3840;
                exportCanvas.height = 3840;
                exportCtx = exportCanvas.getContext('2d');
                
                const scaleX = 3840 / canvas.width;
                const scaleY = 3840 / canvas.height;
                exportCtx.scale(scaleX, scaleY);
                exportCtx.drawImage(canvas, 0, 0);
            } else {
                exportCanvas = canvas;
            }

            exportCanvas.toBlob(function(blob) {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${canvasId}_${resolution}_${Date.now()}.png`;
                a.click();
                URL.revokeObjectURL(url);
            });
        }

        function exportCircleData() {
            const maxM = parseInt(document.getElementById('maxModulus').value);
            const coprimeOnly = document.getElementById('coprimeOnly').checked;

            let csv = 'Modulus,Residue,Angle_Radians,X_Coordinate,Y_Coordinate,Is_Coprime\n';

            for (let m = 1; m <= maxM; m++) {
                for (let r = 0; r < m; r++) {
                    const iscoprime = gcd(r, m) === 1;
                    if (coprimeOnly && !iscoprime) continue;

                    const angle = 2 * Math.PI * r / m;
                    const x = Math.cos(angle);
                    const y = Math.sin(angle);

                    csv += `${m},${r},${angle.toFixed(10)},${x.toFixed(10)},${y.toFixed(10)},${iscoprime ? 1 : 0}\n`;
                }
            }

            downloadCSV(csv, 'unit_circle_data.csv');
        }

        function exportCoprimePairsData() {
            const N = parseInt(document.getElementById('gridSize').value);

            let csv = 'a,b,gcd,is_coprime\n';

            for (let a = 1; a <= N; a++) {
                for (let b = 1; b <= N; b++) {
                    const g = gcd(a, b);
                    csv += `${a},${b},${g},${g === 1 ? 1 : 0}\n`;
                }
            }

            downloadCSV(csv, 'coprime_pairs_data.csv');
        }

        function exportPhiData() {
            const maxM = parseInt(document.getElementById('phiMaxModulus').value);

            let csv = 'Modulus,Phi_m,Ratio_Phi_m_over_m,Is_Prime\n';

            for (let m = 1; m <= maxM; m++) {
                const phi = euler_phi(m);
                const ratio = phi / m;
                const prime = isPrime(m);
                csv += `${m},${phi},${ratio.toFixed(10)},${prime ? 1 : 0}\n`;
            }

            downloadCSV(csv, 'phi_ratios_data.csv');
        }

        function exportConvergenceData() {
            const maxM = 500;

            let csv = 'N,Running_Average_Phi_over_m\n';
            let sum = 0;

            for (let m = 1; m <= maxM; m++) {
                sum += euler_phi(m) / m;
                const avg = sum / m;
                csv += `${m},${avg.toFixed(10)}\n`;
            }

            downloadCSV(csv, 'convergence_data.csv');
        }

        function downloadCSV(csv, filename) {
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
        }

        // Main render function
        function renderAll() {
            renderUnitCircle();
            renderCoprimePairs();
            renderPhiRatios();
            renderConvergence();
        }

        // Initialize on load
        window.onload = function() {
            renderAll();
        };
    </script>
</body>
</html>
