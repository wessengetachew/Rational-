
<html>
<head>
    <title>Analytic Number Theory Visualization (Minimalist Dark Style)</title>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    
    <style>
        /* --- Root Variables for Dark Minimalist Theme --- */
        :root {
            --color-bg-primary: #121212; /* Dark background */
            --color-bg-secondary: #1E1E1E; /* Sidebar/control background */
            --color-text-light: #F0F0F0;
            --color-text-accent: #BB86FC; /* Bright Purple/Magenta */
            --color-accent-highlight: #03DAC6; /* Teal/Cyan for controls */
            --color-border-subtle: #333333;
            --color-chart-line: #424242;
            --font-family-mono: 'Roboto Mono', monospace;
            --font-family-sans: 'Inter', sans-serif;
        }

        /* --- Global Reset and Body --- */
        html, body {
            margin: 0;
            padding: 0;
            height: 100%;
            font-family: var(--font-family-sans);
            color: var(--color-text-light);
            background-color: var(--color-bg-primary);
            overflow: hidden; /* Prevent scrolling of the body */
        }

        /* --- Main Layout: Visualization First --- */
        #container {
            display: flex;
            height: 100vh;
        }
        
        #content { 
            flex-grow: 1; 
            display: flex;
            flex-direction: column;
            padding: 20px;
            overflow-y: auto;
        }

        /* --- Floating Control Panel --- */
        #controls { 
            width: 320px; 
            background: var(--color-bg-secondary); 
            box-shadow: -5px 0 15px rgba(0,0,0,0.5);
            padding: 20px; 
            overflow-y: auto;
            flex-shrink: 0;
            z-index: 100;
        }

        /* --- Typography --- */
        h1 {
            color: var(--color-text-accent);
            font-size: 2.2em;
            margin: 0 0 5px 0;
            font-weight: 700;
        }
        h2.subtitle {
            font-size: 1.1em;
            color: #999;
            margin: 0 0 20px 0;
            font-weight: 300;
        }
        h3 {
            color: var(--color-accent-highlight); 
            font-size: 1.3em;
            font-weight: 600;
            margin-top: 25px;
            margin-bottom: 15px;
            border-bottom: 1px solid var(--color-border-subtle);
            padding-bottom: 5px;
        }
        
        /* --- Visualization Area --- */
        #visualization-area {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        #p5Canvas { 
            display: block; 
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
        }
        
        /* --- Controls & Data Widgets --- */
        .control-group { 
            margin-bottom: 20px; 
            padding: 15px; 
            border: 1px solid var(--color-border-subtle); 
            border-radius: 4px;
        }
        
        label { 
            display: block; 
            margin-bottom: 5px; 
            font-weight: 500;
            font-size: 0.9em;
            color: var(--color-text-light);
        }
        
        input[type=range] { accent-color: var(--color-text-accent); width: 100%;}
        select { 
            width: 100%; 
            padding: 8px; 
            background-color: #2D2D2D; 
            color: var(--color-text-light); 
            border: 1px solid var(--color-border-subtle);
            border-radius: 3px;
        }

        .button-group button { 
            padding: 8px 10px; 
            background-color: var(--color-text-accent); 
            color: var(--color-bg-secondary); 
            border: none; 
            border-radius: 4px; 
            cursor: pointer;
            font-weight: 600;
            transition: background-color 0.2s;
            margin-top: 8px; 
            width: 100%; 
        }
        .button-group button:hover { background-color: #D3A7FF; }
        
        .property-label { font-weight: 400; margin-top: 8px; font-size: 0.85em;}
        .property-value { 
            font-size: 1.1em; 
            font-weight: 700;
            color: var(--color-accent-highlight); 
            font-family: var(--font-family-mono);
        }
        
        /* --- Live Feed (New Widget Style) --- */
        #live-feed {
            width: 95%; 
            max-width: 1000px;
            margin-top: 15px;
            padding: 10px 20px;
            background-color: var(--color-bg-secondary);
            border: 1px solid var(--color-border-subtle);
            border-radius: 4px;
            font-family: var(--font-family-mono);
            font-size: 1.1em;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .live-label { color: #999; font-weight: 400;}
        .live-coords { color: var(--color-accent-highlight); font-weight: 600;}
        
        /* --- Info Section (Hidden by default in this style) --- */
        #info-section {
            display: none; 
        }
    </style>
</head>
<body>

<div id="container">

    <div id="content">
        
        <div id="title-section">
            <h1>Analytic Number Theory Visualizer</h1>
            <h2 class="subtitle">Density of Coprime Pairs: $\zeta(2)$, Farey Sequences, and Multiplicative Functions</h2>
        </div>

        <div id="visualization-area">
            <canvas id="p5Canvas"></canvas> 
             <div id="live-feed">
                 <span class="live-label" id="live-label">LIVE FEED | Lattice (a, b) Coordinates:</span>
                 <span class="live-coords" id="live-coords-value">A: 0, B: 0 | OUT OF RANGE</span>
             </div>
        </div>
        
        <div id="info-section">
             </div>
    </div>
    
    <div id="controls">
        <h3><span style="color: var(--color-text-accent);">I.</span> Core Parameters</h3>

        <div class="control-group">
            <label for="visMode">Visualization Domain (Max Q Varies):</label>
            <select id="visMode" onchange="resetSketch()">
                <option value="circle">Farey Sequence Angles (Unit Circle, Max Q=350)</option>
                <option value="lattice">Coprime Pairs Density (Lattice Plot, Max Q=150)</option>
            </select>
        </div>

        <div class="control-group">
            <label for="limitQ">Limit Q (Maximum Denominator / Axis Extent):</label>
            <input type="range" id="limitQ" min="2" max="350" value="45" step="1" oninput="updateVisualization()">
            <span id="limitQValue" class="property-value">45</span>

            <label for="pointSize" style="margin-top: 15px;">Point Size (WebGL `strokeWeight`):</label>
            <input type="range" id="pointSize" min="0.5" max="5" value="2.5" step="0.1" oninput="updateVisualization()">
        </div>

        <div class="control-group">
            <label for="colorScheme">Color Mapping Function:</label>
            <select id="colorScheme" onchange="updateVisualization()">
                <option value="denominator">By Denominator (q)</option>
                <option value="gcd_coprime">By GCD (=1 vs >1)</option>
                <option value="mobius">By MÃ¶bius $\mu(q)$</option>
                <option value="omega">By Distinct Prime Count $\omega(q)$</option>
                <option value="divisor_sum">By Divisor Sum $\sigma(q)$</option>
                <option value="none">None (Uniform Color)</option>
            </select>
            
            <label for="saturation" style="margin-top: 15px;">Color Saturation (HSB):</label>
            <input type="range" id="saturation" min="50" max="100" value="80" step="1" oninput="updateVisualization()">
        </div>
        
        <div class="control-group">
            <h3><span style="color: var(--color-text-accent);">II.</span> Metrics (Q=<span id="propQ" class="property-value">45</span>)</h3>
            
            <p class="property-label">Total Points Plotted:</p> 
            <strong id="propFarey" class="property-value">0</strong>
            
            <p class="property-label">Total Coprime Pairs $A_Q$ in $Q \times Q$:</p> 
            <strong id="propTotalCoprime" class="property-value">0</strong>
            
            <hr style="border-top: 1px dashed var(--color-border-subtle); margin: 15px 0;">
            
            <p class="property-label" style="font-weight: 600;">Asymptotic Ratio: $|F_Q| / Q^2$</p> 
            <strong id="propRatio" class="property-value">0.000000</strong>
        </div>

        <div class="button-group">
            <button onclick="exportPNG()">Export Visualization (PNG)</button>
            <button onclick="exportCSV('main_points')">Export Raw Data (CSV)</button>
        </div>
        
    </div>
</div> <script>
    //================================================================================================
    // [JAVASCRIPT UTILITY LIBRARY: MATH AND NUMBER THEORY] 
    //================================================================================================
    
    const PI = Math.PI;
    const ZETA2_INV_HALF = (6 / (PI * PI)) / 2; 

    // Global state and Configuration
    let Q_current = 45; 
    
    // Canvas dimensions (Dynamically set later)
    let CANVAS_W = 1; 
    let CANVAS_H = 1; 
    
    // Plot configuration 
    const PLOT_W = 300; 
    const PLOT_H = 300;
    const CHART_Y_OFFSET = 200; // Vertical space for main chart area
    
    let dataCache = {};
    let pointSize = 2.5;
    let axisColor;
    let bgColor;
    let dashboardGraphics; 
    
    // Tooltip and Live Feed State
    let hoveredPoint = null; 
    let hoveredPointScreenX = 0;
    let hoveredPointScreenY = 0;

    // Camera Lock State
    let isMouseOverControls = false;

    // --- Math Utilities (Simplified for brevity, assumes p5 is loaded) ---
    function gcd(a, b) { 
        if (a === 0) return b;
        while (b) { [a, b] = [b, a % b]; }
        return a;
    }
    let primes = []; let isPrimeCalculatedUpTo = 0;
    function sieve(n) {
        if (n <= isPrimeCalculatedUpTo) return;
        const is_prime = new Array(n + 1).fill(true);
        is_prime[0] = is_prime[1] = false;
        for (let p = 2; p * p <= n; p++) {
            if (is_prime[p]) {
                for (let i = p * p; i <= n; i += p) is_prime[i] = false;
            }
        }
        primes = [];
        for (let p = 2; p <= n; p++) { if (is_prime[p]) primes.push(p); }
        isPrimeCalculatedUpTo = n;
    }
    // Note: Other number theory functions (omega, phi, mobius, divisorSum) are included in the full code, 
    // but simplified/omitted here for conciseness as their implementations are identical to the previous version.
    
    function phi(n) {
        if (n === 0) return 0;
        let result = n; let temp = n; sieve(Math.ceil(Math.sqrt(n))); 
        for (let p of primes) {
            if (p * p > temp) break;
            if (temp % p === 0) { while (temp % p === 0) temp /= p; result -= result / p; }
        }
        if (temp > 1) result -= result / temp;
        return Math.round(result);
    }
    function mobius(n) {
        if (n === 1) return 1;
        let factors = 0; let temp = n; sieve(Math.ceil(Math.sqrt(n)));
        for (let p of primes) {
            if (p * p > temp) break;
            if (temp % p === 0) { factors++; temp /= p; if (temp % p === 0) return 0; }
        }
        if (temp > 1) factors++; 
        return (factors % 2 === 0) ? 1 : -1;
    }
    function omega(n) {
        if (n === 1) return 0;
        let count = 0; let temp = n; sieve(Math.ceil(Math.sqrt(n))); 
        for (let p of primes) {
            if (p * p > temp) break;
            if (temp % p === 0) { count++; while (temp % p === 0) temp /= p; }
        }
        if (temp > 1) count++; 
        return count;
    }
    function divisorSum(n) {
        if (n === 1) return 1;
        let sum = 1; let temp = n; sieve(Math.ceil(Math.sqrt(n)));
        for (let p of primes) {
            if (p * p > temp) break;
            if (temp % p === 0) {
                let p_pow = p; let term_sum = 1;
                while (temp % p === 0) { term_sum += p_pow; p_pow *= p; temp /= p; }
                sum *= term_sum;
            }
        }
        if (temp > 1) sum *= (1 + temp);
        return sum;
    }

    // --- Data Generation ---
    function getPointsAndProperties(Q) {
        let fractions = []; let reducedCoprimeCount = 0; 
        let ratio_history = [];
        let current_F = 1; 
        
        for (let q = 1; q <= Q; q++) {
            const phi_q = phi(q);
            current_F += phi_q;
            ratio_history.push({ q: q, ratio: current_F / (q * q) });

            for (let a = 1; a < q; a++) { 
                if (gcd(a, q) === 1) {
                    fractions.push({ a: a, q: q, value: a / q, phi: phi_q, mu: mobius(q), sigma: divisorSum(q), omega: omega(q) });
                    reducedCoprimeCount++;
                }
            }
            if (q === 1) {
                fractions.push({ a: 0, q: 1, value: 0, phi: 1, mu: 1, sigma: 1, omega: 0 });
                fractions.push({ a: 1, q: 1, value: 1, phi: 1, mu: 1, sigma: 1, omega: 0 });
            }
        }
        
        let A_Q = 0;
        sieve(Q);
        for (let d = 1; d <= Q; d++) {
            A_Q += mobius(d) * Math.floor(Q / d) * Math.floor(Q / d);
        }
        
        let latticePoints = [];
        for (let a = 1; a <= Q; a++) {
            for (let b = 1; b <= Q; b++) {
                const g = gcd(a, b);
                latticePoints.push({
                    a: a, b: b, gcd_val: g, is_coprime: (g === 1),
                    prop_value: g, 
                    mu: mobius(b), omega: omega(b), sigma: divisorSum(b),
                });
            }
        }
        
        return { fractions, latticePoints, FareyCount: current_F - 1, B_Q: reducedCoprimeCount, A_Q: A_Q, ratio_history }; 
    }
    
    //================================================================================================
    // [P5.JS CORE IMPLEMENTATION] 
    //================================================================================================

    function setup() {
        // Dynamic Canvas Size: Use available space (subtracting some padding/margins)
        CANVAS_W = document.getElementById('content').clientWidth - 40;
        CANVAS_H = windowHeight - 200; // Leave space for title and charts
        
        // Ensure minimum size for visibility
        CANVAS_W = Math.max(CANVAS_W, 800); 
        CANVAS_H = Math.max(CANVAS_H, 700); 
        
        let canvas = createCanvas(CANVAS_W, CANVAS_H, WEBGL); 
        canvas.id('p5Canvas'); 
        canvas.parent('visualization-area');
        colorMode(HSB, 360, 100, 100);
        
        // Create the P2D graphics buffer for UI (charts, tooltips, axis labels)
        dashboardGraphics = createGraphics(CANVAS_W, CANVAS_H, P2D);
        dashboardGraphics.colorMode(HSB, 360, 100, 100);

        // Initial setup
        resetSketch(); 
    }
    
    function windowResized() {
        // Recalculate size and resize canvas on window resize
        CANVAS_W = document.getElementById('content').clientWidth - 40;
        CANVAS_H = windowHeight - 200;
        
        CANVAS_W = Math.max(CANVAS_W, 800); 
        CANVAS_H = Math.max(CANVAS_H, 700); 
        
        resizeCanvas(CANVAS_W, CANVAS_H);
        dashboardGraphics.resizeCanvas(CANVAS_W, CANVAS_H);
        updateVisualization();
    }
    
    function checkMouseOverControls() {
        // Check if the mouse is over the floating control sidebar
        const controlsDiv = document.getElementById('controls');
        const rect = controlsDiv.getBoundingClientRect();
        
        const mouseXPage = window.scrollX + mouseX;
        const mouseYPage = window.scrollY + mouseY;
        
        return (mouseXPage >= rect.left && mouseXPage <= rect.right && mouseYPage >= rect.top && mouseYPage <= rect.bottom);
    }
    
    function mouseMoved() { isMouseOverControls = checkMouseOverControls(); return !isMouseOverControls; }
    function mouseDragged() { isMouseOverControls = checkMouseOverControls(); return !isMouseOverControls; }

    
    function resetSketch() {
        const visMode = document.getElementById('visMode').value;
        const maxQ = (visMode === 'circle') ? 350 : 150;
        document.getElementById('limitQ').max = maxQ; 
        
        if (Q_current > maxQ) {
            Q_current = maxQ;
            document.getElementById('limitQ').value = Q_current;
        } else if (Q_current < 2) {
            Q_current = 2;
            document.getElementById('limitQ').value = Q_current;
        }
        
        dataCache = {}; 
        updateVisualization();
    }
    
    function updateVisualization() {
        Q_current = parseInt(document.getElementById('limitQ').value);
        pointSize = parseFloat(document.getElementById('pointSize').value);

        document.getElementById('limitQValue').textContent = Q_current;
        document.getElementById('propQ').textContent = Q_current;
        
        // Get colors from CSS variables for P5
        const rootStyles = getComputedStyle(document.documentElement);
        const textColorHex = rootStyles.getPropertyValue('--color-text-light');
        const controlBgHex = rootStyles.getPropertyValue('--color-bg-secondary');
        
        axisColor = color(textColorHex);
        bgColor = color(controlBgHex);

        if (!dataCache[Q_current]) {
            dataCache[Q_current] = getPointsAndProperties(Q_current);
        }
        
        const data = dataCache[Q_current];
        const finalRatio = data.ratio_history[data.ratio_history.length - 1].ratio;

        // Update data panel (HTML)
        document.getElementById('propFarey').textContent = data.FareyCount.toLocaleString();
        document.getElementById('propTotalCoprime').textContent = data.A_Q.toLocaleString();
        document.getElementById('propRatio').textContent = finalRatio.toFixed(6);

        // Update live feed label
        document.getElementById('live-label').textContent = (document.getElementById('visMode').value === 'circle' ? 
            'LIVE FEED | Farey Angle Coordinates:' : 'LIVE FEED | Lattice (a, b) Coordinates:');
    }
    
    function draw() {
        if (!dataCache[Q_current]) return; 
        const data = dataCache[Q_current];
        const visMode = document.getElementById('visMode').value;
        
        // 1. WEBGL Setup
        clear();
        push();
        translate(0, 0, -100); 
        fill(bgColor);
        noStroke();
        plane(CANVAS_W * 2, CANVAS_H * 2); 
        pop();
        
        strokeWeight(pointSize);
        if (!isMouseOverControls) { orbitControl(); }
        
        // 2. Draw Main Visualization
        const mainPlotYOffset = 0; // Use the center of the canvas for this minimalist style
        const mainPlotRadius = CANVAS_H * 0.45; 
        const mainPlotSize = CANVAS_W * 0.8; 
        
        push();
        translate(0, mainPlotYOffset, 0); 
        
        const centerX = 0;
        const centerY = mainPlotYOffset;

        if (visMode === 'circle') {
            hoveredPoint = findClosestPoint(data.fractions, centerX, centerY, 'circle', mainPlotRadius);
            drawUnitCircleWebGL(data.fractions, mainPlotRadius);
        } else {
            hoveredPoint = findClosestPoint(data.latticePoints, centerX, centerY, 'lattice', mainPlotSize);
            drawCoprimeLatticeWebGL(data.latticePoints, mainPlotSize);
        }
        pop();
        
        // 3. Draw 2D UI Overlay 
        drawUIOverlay(dashboardGraphics, data, visMode);
        image(dashboardGraphics, -CANVAS_W/2, -CANVAS_H/2);
    }
    
    // --- POINT PICKING LOGIC ---
    function findClosestPoint(dataPoints, centerX, centerY, mode, plotDim) {
        const mouseXCanvas = mouseX - CANVAS_W / 2;
        const mouseYCanvas = mouseY - CANVAS_H / 2;
        let closestPoint = null;
        let minDistanceSq = 100; 
        
        const radius = plotDim; 
        const scaleFactor = plotDim / Q_current;

        for (let p of dataPoints) {
            let px, py; 

            if (mode === 'circle') {
                const angle = -2 * PI * p.value; 
                const x_3d = radius * cos(angle);
                const y_3d = 0; 
                const z_3d = radius * sin(angle); 
                
                px = screenX(x_3d, y_3d, z_3d); 
                py = screenY(x_3d, y_3d, z_3d);
                
            } else { // mode === 'lattice'
                const x_3d = p.a * scaleFactor - plotDim/2;
                const y_3d = -(p.b * scaleFactor - plotDim/2); 
                const z_3d = 0; 
                
                px = screenX(x_3d, y_3d, z_3d); 
                py = screenY(x_3d, y_3d, z_3d);
            }
            
            const dx = px - mouseXCanvas;
            const dy = py - mouseYCanvas;
            const distSq = dx * dx + dy * dy;

            if (distSq < minDistanceSq) {
                minDistanceSq = distSq;
                closestPoint = p;
                hoveredPointScreenX = px + CANVAS_W / 2; 
                hoveredPointScreenY = py + CANVAS_H / 2;
            }
        }
        return closestPoint;
    }
    
    // --- COLORING LOGIC ---
    function getPointColor(p, scheme, isLattice) {
        if (scheme === 'none' || (isLattice && scheme === 'gcd_coprime' && p.gcd_val !== 1)) { 
            // Use accent color for coprime points when color mapping is turned off or on gcd filter
            return isLattice && p.gcd_val === 1 ? color(270, 80, 100) : color(300, 10, 50); 
        }
        
        const sat_val = parseInt(document.getElementById('saturation').value);
        const bright_val = 90; // Fixed high brightness for dark mode visibility

        // Standard coloring logic remains the same (HSB hue mapping)
        if (scheme === 'mobius') {
            if (p.mu === 1) return color(220, sat_val, bright_val); 
            if (p.mu === -1) return color(0, sat_val, bright_val);  
            return color(0, 0, 50); 
        }
        if (scheme === 'omega') {
            const maxOmega = Math.max(3, ...dataCache[Q_current].fractions.map(f => f.omega));
            let hue = map(p.omega, 0, maxOmega, 180, 300); 
            return color(hue, sat_val, bright_val);
        }
        
        let propValues = isLattice ? dataCache[Q_current].latticePoints.map(p => p.prop_value) : (scheme === 'divisor_sum' ? dataCache[Q_current].fractions.map(p => p.sigma) : dataCache[Q_current].fractions.map(p => p.q));
        let minVal = Math.min(...propValues.filter(v => v > 0)); 
        let maxVal = Math.max(...propValues);
        if (maxVal === 0 || maxVal <= minVal) maxVal = minVal + 1;
        
        const val = isLattice ? p.prop_value : (scheme === 'divisor_sum' ? p.sigma : p.q);
        
        let hue = map(val, minVal, maxVal, 200, 360); // Hue from cyan/blue to magenta/red
        return color(hue, sat_val, bright_val);
    }
    
    // --- VISUALIZATION DRAWING ---
    function drawUnitCircleWebGL(fractions, radius) {
        push();
        const scheme = document.getElementById('colorScheme').value;
        
        // Draw the circle guide
        push();
        stroke(axisColor); noFill(); strokeWeight(1);
        rotateX(PI/2); 
        torus(radius, 1, 100, 100); 
        pop();

        // Draw points
        beginShape(POINTS);
        for (let p of fractions) {
            const angle = -2 * PI * p.value; 
            const x = radius * cos(angle);
            const z = radius * sin(angle); 
            
            stroke(getPointColor(p, scheme, false));
            vertex(x, 0, z); 
        }
        endShape();
        
        // Highlight Hovered Point
        if (hoveredPoint && hoveredPoint.q) {
            const p = hoveredPoint;
            const angle = -2 * PI * p.value; 
            const x = radius * cos(angle);
            const z = radius * sin(angle);
            
            push();
            stroke(color(300, 100, 100)); // Bright magenta highlight
            strokeWeight(pointSize * 2.5);
            point(x, 0, z);
            pop();
        }
        
        pop();
    }

    function drawCoprimeLatticeWebGL(latticePoints, plotSize) {
        push();
        
        // Center the 1st quadrant plot
        translate(-plotSize/2, plotSize/2, 0); 
        
        // Draw Axes
        stroke(axisColor); strokeWeight(1);
        line(0, 0, plotSize, 0); // X-axis (a)
        line(0, 0, 0, -plotSize); // Y-axis (b)
        
        const scheme = document.getElementById('colorScheme').value;
        const scaleFactor = plotSize / Q_current;
        
        // Plot points
        beginShape(POINTS);
        for (let p of latticePoints) {
            const x = p.a * scaleFactor;
            const y = -p.b * scaleFactor; 
            
            stroke(getPointColor(p, scheme, true));
            vertex(x, y, 0); 
        }
        endShape();
        
        // Highlight Hovered Point
        if (hoveredPoint && hoveredPoint.a && hoveredPoint.b) {
            const p = hoveredPoint;
            const x = p.a * scaleFactor;
            const y = -p.b * scaleFactor; 
            
            push();
            stroke(color(300, 100, 100)); // Bright magenta highlight
            strokeWeight(pointSize * 2.5);
            point(x, y, 0);
            pop();
        }
        
        pop();
    }
    
    // --- DRAW 2D UI OVERLAY ---
    function drawUIOverlay(pg, data, visMode) {
        pg.clear();
        pg.background(0, 0, 0, 0); 
        
        // 1. Update HTML Live Feed
        updateHTMLLiveFeed(visMode);

        // 2. Draw Dashboard Charts below visualization area
        const chartY = CANVAS_H * 0.75; // Position charts lower in the frame
        pg.push(); pg.translate(10, chartY); drawRatioConvergenceP2D(pg, data.ratio_history); pg.pop();
        pg.push(); pg.translate(CANVAS_W - PLOT_W - 10, chartY); drawMobiusSequenceP2D(pg, data.mobius_history); pg.pop();
        
        // 3. Draw Tooltip
        if (hoveredPoint) {
            drawTooltipP2D(pg, hoveredPoint, visMode);
        }
    }
    
    // NEW: Update HTML Live Feed Widget
    function updateHTMLLiveFeed(visMode) {
        const liveCoordsElement = document.getElementById('live-coords-value');
        
        let coordText;
        const plotSize = CANVAS_W * 0.8;
        const scaleFactor = plotSize / Q_current;
        
        // P2D coordinates of the plot origin (0,0 of the lattice/circle center)
        const plotOriginX = CANVAS_W / 2 - plotSize / 2;
        const plotOriginY = CANVAS_H / 2 + plotSize / 2;

        const plotX_P2D = mouseX - plotOriginX;
        const plotY_P2D = plotOriginY - mouseY; 

        let a_approx = Math.round(plotX_P2D / scaleFactor);
        let b_approx = Math.round(plotY_P2D / scaleFactor);
        
        if (a_approx >= 1 && a_approx <= Q_current && b_approx >= 1 && b_approx <= Q_current) {
            if (visMode === 'circle') {
                 // For circle, we just show screen position when in bounds, as (a,q) is hard to map in reverse
                 coordText = `X: ${mouseX}, Y: ${mouseY}`;
            } else {
                 coordText = `A: ${a_approx}, B: ${b_approx}`;
            }
        } else {
             coordText = `A: 0, B: 0 | OUT OF RANGE`;
        }
        
        liveCoordsElement.textContent = coordText;
    }

    // --- TOOLTIP DRAWING ---
    function drawTooltipP2D(pg, p, mode) {
        let lines = [];
        
        const rootStyles = getComputedStyle(document.documentElement);
        const controlBg = color(rootStyles.getPropertyValue('--color-bg-secondary'));
        const textColor = color(rootStyles.getPropertyValue('--color-text-light'));

        if (mode === 'circle') {
            lines.push(`Fraction: ${p.a}/${p.q}`);
            lines.push(`Value: ${p.value.toFixed(6)}`);
            lines.push(`\u03C6(q): ${p.phi}`); 
            lines.push(`\u03BC(q): ${p.mu}`); 
        } else { // lattice
            lines.push(`Coords: (${p.a}, ${p.b})`);
            lines.push(`GCD: ${p.gcd_val} ${p.is_coprime ? '(\u2713 Coprime)' : ''}`);
            lines.push(`\u03C6(b): ${phi(p.b)}`);
            lines.push(`\u03BC(b): ${mobius(p.b)}`); 
        }

        const padding = 8;
        pg.textSize(12);
        
        let maxW = 0;
        for (let line of lines) { maxW = Math.max(maxW, pg.textWidth(line)); }

        const boxW = maxW + padding * 2;
        const boxH = lines.length * 15 + padding * 2; 

        let x = hoveredPointScreenX + 10;
        let y = hoveredPointScreenY - boxH / 2;
        
        // Boundary checks
        if (x + boxW > CANVAS_W) x = hoveredPointScreenX - boxW - 10;
        if (y < 0) y = 0;
        if (y + boxH > CANVAS_H * 0.70) y = CANVAS_H * 0.70 - boxH;

        // Draw box (use the dark secondary background)
        pg.fill(controlBg); 
        pg.stroke(color(300, 100, 100)); // Magenta border
        pg.rect(x, y, boxW, boxH, 3);
        
        // Draw text
        pg.fill(textColor);
        pg.textAlign(LEFT, TOP);
        for (let i = 0; i < lines.length; i++) {
            pg.text(lines[i], x + padding, y + padding + i * 15);
        }
    }

    // --- CHART DRAWING FUNCTIONS (Only 2 charts for minimalist style) ---
    
    function drawRatioConvergenceP2D(pg, ratioHistory) {
        const chartW = PLOT_W; const chartH = PLOT_H; const margin = 30;
        pg.noFill(); pg.stroke(axisColor); pg.rect(0, 0, chartW, chartH);
        
        const minY = 0.28; const maxY = Math.max(...ratioHistory.map(d => d.ratio), 0.5);
        const asymptoticY = map(ZETA2_INV_HALF, minY, maxY, chartH - margin, margin); 
        
        // Asymptotic Line
        pg.stroke(color(180, 80, 80)); // Cyan/Teal line
        pg.strokeWeight(2);
        pg.line(0, asymptoticY, chartW, asymptoticY);
        pg.fill(axisColor); pg.textSize(10); pg.textAlign(RIGHT, CENTER);
        pg.text(`Target 3 / \u03C0\u00B2`, chartW - 5, asymptoticY - 8);

        // Data Line
        pg.noFill(); pg.stroke(color(300, 80, 80)); // Magenta line
        pg.strokeWeight(2); 
        
        pg.beginShape();
        for (let i = 0; i < ratioHistory.length; i++) {
            const data = ratioHistory[i];
            const x = map(data.q, 1, Q_current, 0, chartW);
            const y = map(data.ratio, minY, maxY, chartH - margin, margin);
            pg.vertex(x, y);
        }
        pg.endShape();
        
        pg.fill(axisColor);
        pg.textSize(14);
        pg.textAlign(CENTER, TOP);
        pg.text("Ratio Convergence: |F\u208BQ\u208C| / Q\u00B2", chartW / 2, 5); 
    }
    
    function drawMobiusSequenceP2D(pg, mobiusData) {
        const chartW = PLOT_W; const chartH = PLOT_H; const margin = 30;
        const plotAreaH = chartH - margin * 2;
        const midpointY = chartH - margin - plotAreaH / 2;

        pg.noFill(); pg.stroke(axisColor); pg.rect(0, 0, chartW, chartH);
        pg.stroke(axisColor); pg.line(0, midpointY, chartW, midpointY);
        
        // M(Q) summation line
        pg.stroke(color(60, 80, 80)); 
        for (let i = 1; i < mobiusData.length; i++) {
            const data = mobiusData[i];
            const prevData = mobiusData[i-1];
            
            const x = map(data.q, 1, Q_current, 0, chartW);
            const prevX = map(prevData.q, 1, Q_current, 0, chartW);
            
            const M_y = map(data.M_q, -Q_current / 2, Q_current / 2, midpointY + plotAreaH / 2, midpointY - plotAreaH / 2);
            const prevM_y = map(prevData.M_q, -Q_current / 2, Q_current / 2, midpointY + plotAreaH / 2, midpointY - plotAreaH / 2);
            
            pg.line(prevX, prevM_y, x, M_y);
        }
        
        pg.fill(axisColor);
        pg.textSize(14);
        pg.textAlign(CENTER, TOP);
        pg.text("Mertens Function M(Q) = \u03A3\u03BC(q)", chartW / 2, 5); 
    }
    
    // --- Export Functions ---
    function exportPNG() { 
        const visMode = document.getElementById('visMode').value;
        const filename = visMode + '_Q' + Q_current + '_Minimalist.png';
        saveCanvas(filename, 'png'); 
    }
    
    function exportCSV(dataType) { 
        const data = dataCache[Q_current];
        let csvContent = "";
        let filename = "Data_Q" + Q_current;
        const visMode = document.getElementById('visMode').value;

        if (!data) {
            alert("Please calculate data first by setting Q.");
            return;
        }

        if (dataType === 'main_points') {
            if (visMode === 'circle') {
                csvContent = "q,a,Fraction_Value,Angle_Radians,Phi_q,Mu_q,Omega_q,Sigma_q\n";
                for (let p of data.fractions) {
                    csvContent += `${p.q},${p.a},${p.value.toFixed(8)},${(p.value * 2 * PI).toFixed(6)},${p.phi},${p.mu},${p.omega},${p.sigma}\n`;
                }
                filename = "Farey_Angles_Q" + Q_current + ".csv";
            } else {
                csvContent = "a,b,GCD_Value,Is_Coprime,Mu_b,Omega_b,Sigma_b\n";
                for (let p of data.latticePoints) {
                    csvContent += `${p.a},${p.b},${p.gcd_val},${p.is_coprime ? 'TRUE' : 'FALSE'},${mobius(p.b)},${omega(p.b)},${divisorSum(p.b)}\n`;
                }
                filename = "Coprime_Lattice_Q" + Q_current + ".csv";
            }
        } else if (dataType === 'ratio') {
            csvContent = "Q,Farey_Count_FQ,Ratio_FQ_div_Q2\n";
            for (let d of data.ratio_history) {
                csvContent += `${d.q},${(d.q * d.q * d.ratio).toFixed(0)},${d.ratio.toFixed(8)}\n`;
            }
            filename = "Ratio_Convergence_Q" + Q_current + ".csv";
        } else {
            alert("Invalid data type specified for export.");
            return;
        }

        let encodedUri = "data:text/csv;charset=utf-8," + encodeURIComponent(csvContent);
        let link = document.createElement("a");
        link.setAttribute("href", encodedUri);
        link.setAttribute("download", filename);
        document.body.appendChild(link); 
        link.click();
        document.body.removeChild(link);
    }
</script>
</body>
</html>
