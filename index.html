
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Infinite Moduli, Roots of Unity, and Coprime Density</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Palatino Linotype', 'Book Antiqua', Palatino, serif;
            background: #fafafa;
            color: #1a1a1a;
            line-height: 1.6;
            padding: 20px;
        }
        
        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: white;
            padding: 40px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        header {
            text-align: center;
            margin-bottom: 50px;
            border-bottom: 2px solid #333;
            padding-bottom: 30px;
        }
        
        h1 {
            font-size: 2.2em;
            font-weight: 600;
            margin-bottom: 15px;
            color: #1a1a1a;
        }
        
        .subtitle {
            font-size: 1.3em;
            color: #555;
            font-style: italic;
            margin-bottom: 20px;
        }
        
        .author {
            font-size: 1.1em;
            color: #333;
            margin-top: 20px;
        }
        
        h2 {
            font-size: 1.6em;
            margin-top: 40px;
            margin-bottom: 20px;
            color: #2c3e50;
            border-bottom: 1px solid #ddd;
            padding-bottom: 10px;
        }
        
        h3 {
            font-size: 1.3em;
            margin-top: 30px;
            margin-bottom: 15px;
            color: #34495e;
        }
        
        .abstract {
            background: #f8f9fa;
            padding: 25px;
            margin: 30px 0;
            border-left: 4px solid #3498db;
            font-size: 1.05em;
        }
        
        .theorem {
            background: #fff9e6;
            padding: 20px;
            margin: 20px 0;
            border-left: 4px solid #f39c12;
        }
        
        .theorem-title {
            font-weight: 700;
            color: #d68910;
            margin-bottom: 10px;
        }
        
        .canvas-container {
            margin: 30px 0;
            text-align: center;
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            border: 1px solid #dee2e6;
        }
        
        canvas {
            border: 1px solid #ddd;
            background: white;
            display: block;
            margin: 20px auto;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        .controls {
            background: #e8f4f8;
            padding: 25px;
            margin: 20px 0;
            border-radius: 8px;
            border: 2px solid #3498db;
        }

        .controls-header {
            font-size: 1.2em;
            font-weight: 700;
            color: #2c3e50;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid #3498db;
        }
        
        .control-group {
            margin: 15px 0;
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        label {
            display: inline-block;
            min-width: 200px;
            font-weight: 600;
            color: #495057;
        }
        
        input[type="range"] {
            flex: 1;
            max-width: 400px;
            height: 8px;
            border-radius: 4px;
            background: linear-gradient(90deg, #3498db, #2ecc71);
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            background: #e74c3c;
            border: 2px solid white;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }

        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #e74c3c;
            border: 2px solid white;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }
        
        input[type="number"] {
            width: 100px;
            padding: 8px;
            border: 2px solid #ced4da;
            border-radius: 4px;
            font-size: 1em;
        }

        input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }
        
        button {
            background: #3498db;
            color: white;
            border: none;
            padding: 12px 24px;
            margin: 5px;
            cursor: pointer;
            font-size: 1em;
            border-radius: 6px;
            transition: all 0.3s;
            font-weight: 600;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        button:hover {
            background: #2980b9;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        
        button:active {
            background: #21618c;
            transform: translateY(0);
        }

        button.reset-btn {
            background: #e74c3c;
        }

        button.reset-btn:hover {
            background: #c0392b;
        }

        button.export-all {
            background: #27ae60;
            font-size: 1.1em;
            padding: 14px 30px;
        }

        button.export-all:hover {
            background: #229954;
        }
        
        .export-buttons {
            text-align: center;
            margin: 20px 0;
            padding: 15px;
            background: #f0f7ff;
            border-radius: 6px;
        }

        .export-section {
            margin: 30px 0;
            padding: 25px;
            background: #fff9e6;
            border: 2px solid #f39c12;
            border-radius: 8px;
        }

        .export-section h3 {
            color: #d68910;
            margin-top: 0;
        }

        .checkbox-group {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 12px;
            background: white;
            border: 2px solid #dee2e6;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .checkbox-item:hover {
            border-color: #3498db;
            background: #f8f9fa;
        }

        .checkbox-item input:checked + label {
            color: #27ae60;
            font-weight: 700;
        }

        .color-indicator {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            border: 2px solid #333;
            flex-shrink: 0;
        }
        
        .stats-panel {
            background: #e8f4f8;
            padding: 25px;
            margin: 20px 0;
            border-radius: 8px;
            border: 2px solid #3498db;
        }

        .stats-panel h3 {
            color: #2c3e50;
            margin-top: 0;
            margin-bottom: 20px;
            font-size: 1.4em;
        }
        
        .stat-item {
            margin: 12px 0;
            font-size: 1.05em;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            background: white;
            border-radius: 4px;
        }
        
        .stat-label {
            font-weight: 600;
            color: #2c3e50;
        }
        
        .stat-value {
            color: #e74c3c;
            font-family: 'Courier New', monospace;
            font-weight: 700;
            font-size: 1.1em;
        }
        
        .math {
            font-style: italic;
            font-family: 'Times New Roman', serif;
        }
        
        .section-content {
            margin: 20px 0;
            text-align: justify;
        }
        
        .interpretation {
            background: #f0f7ff;
            padding: 25px;
            margin: 20px 0;
            border-left: 4px solid #5dade2;
            border-radius: 4px;
        }
        
        .value-display {
            display: inline-block;
            min-width: 80px;
            text-align: center;
            font-weight: 700;
            color: #e74c3c;
            font-size: 1.1em;
            background: white;
            padding: 4px 12px;
            border-radius: 4px;
            border: 2px solid #e74c3c;
        }

        .zoom-controls {
            background: #fff3cd;
            padding: 20px;
            margin: 15px 0;
            border-radius: 6px;
            border: 2px solid #ffc107;
        }

        .zoom-controls h4 {
            color: #856404;
            margin-bottom: 15px;
        }

        .multi-canvas-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }

        .loading {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 30px 50px;
            border-radius: 10px;
            font-size: 1.2em;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <div class="loading" id="loading">Generating export...</div>
    
    <div class="container">
        <header>
            <h1>Infinite Moduli, Roots of Unity, and the Density of Coprime Channels</h1>
            <div class="subtitle">An Interactive Exploration of Classical Results in Analytic Number Theory</div>
            <div class="author">by Wessen Getachew (@7dview)</div>
        </header>

        <div class="abstract">
            <strong>Abstract:</strong> This interactive document explores the classical connection between rational points on the unit circle arising from roots of unity, the density of coprime integer pairs, and the asymptotic behavior of Farey sequences. We demonstrate that while the set of all rational angles is dense on the unit circle, the subset corresponding to reduced fractions (coprime numerator and denominator) has natural density 3/Ï€Â². The global average of Ï†(m)/m over all moduli converges to 6/Ï€Â², reconciling the fact that prime moduli individually approach density 1 while having measure zero in the integers.
        </div>

        <!-- Multi-Canvas Export Section -->
        <div class="export-section">
            <h3>ðŸŽ¯ Multi-Canvas Export System</h3>
            <p style="margin-bottom: 20px;">Select any combination of visualizations to export together. The system will automatically arrange them in an optimal grid layout with a comprehensive legend.</p>
            
            <div class="checkbox-group">
                <label class="checkbox-item">
                    <input type="checkbox" class="canvas-export-checkbox" value="circle" checked>
                    <span class="color-indicator" style="background: #e74c3c;"></span>
                    <span>Unit Circle</span>
                </label>
                <label class="checkbox-item">
                    <input type="checkbox" class="canvas-export-checkbox" value="nested" checked>
                    <span class="color-indicator" style="background: #9b59b6;"></span>
                    <span>Nested Rings</span>
                </label>
                <label class="checkbox-item">
                    <input type="checkbox" class="canvas-export-checkbox" value="pairs" checked>
                    <span class="color-indicator" style="background: #3498db;"></span>
                    <span>Coprime Pairs Grid</span>
                </label>
                <label class="checkbox-item">
                    <input type="checkbox" class="canvas-export-checkbox" value="phi" checked>
                    <span class="color-indicator" style="background: #27ae60;"></span>
                    <span>Ï†(m)/m Ratios</span>
                </label>
                <label class="checkbox-item">
                    <input type="checkbox" class="canvas-export-checkbox" value="convergence" checked>
                    <span class="color-indicator" style="background: #f39c12;"></span>
                    <span>Convergence Chart</span>
                </label>
            </div>

            <div style="text-align: center; margin-top: 20px;">
                <div style="margin-bottom: 15px;">
                    <button onclick="selectAllCanvasExports()">Select All</button>
                    <button onclick="deselectAllCanvasExports()">Deselect All</button>
                </div>
                <div id="exportCount" style="color: #27ae60; font-weight: 700; font-size: 1.1em; margin-bottom: 15px;">
                    5 canvases selected
                </div>
                <label style="margin-right: 20px;">
                    <input type="checkbox" id="includeExportLegend" checked> Include Legend
                </label>
                <label style="margin-right: 20px;">
                    <input type="checkbox" id="includeExportParameters" checked> Include Parameters
                </label>
                <label>
                    Export Resolution:
                    <select id="exportResolution" style="padding: 8px; margin-left: 10px; font-size: 1em;">
                        <option value="1080">Full HD (1920Ã—1080)</option>
                        <option value="1440">2K (2560Ã—1440)</option>
                        <option value="4k" selected>4K UHD (3840Ã—2160)</option>
                        <option value="8k">8K UHD (7680Ã—4320)</option>
                    </select>
                </label>
            </div>
            <div style="text-align: center; margin-top: 20px;">
                <button class="export-all" onclick="exportMultipleCanvases()">
                    ðŸ“Š Export Selected Canvases
                </button>
            </div>
        </div>

        <h2>1. Unit Circle and Rational Angles</h2>
        <div class="section-content">
            <p>For each modulus <span class="math">m</span>, the reduced residue system Î¦(<span class="math">m</span>) = {<span class="math">r</span> : gcd(<span class="math">r</span>, <span class="math">m</span>) = 1, 0 â‰¤ <span class="math">r</span> < <span class="math">m</span>} maps to points on the unit circle via <span class="math">r</span> â†’ exp(2Ï€<span class="math">i r</span>/<span class="math">m</span>). The visualization below shows these points for varying moduli.</p>
        </div>

        <div class="controls">
            <div class="controls-header">Unit Circle Controls</div>
            <div class="control-group">
                <label>Maximum Modulus:</label>
                <input type="range" id="maxModulus" min="1" max="100" value="20" oninput="updateModulusDisplay(this.value); renderAll()">
                <span class="value-display" id="maxModulusValue">20</span>
            </div>
            <div class="control-group">
                <label>Show Coprime Only:</label>
                <input type="checkbox" id="coprimeOnly" checked onchange="renderAll()">
            </div>
            <div class="control-group">
                <label>Point Size:</label>
                <input type="range" id="pointSize" min="1" max="12" value="4" oninput="updatePointSizeDisplay(this.value); renderAll()">
                <span class="value-display" id="pointSizeValue">4</span>
            </div>
            <div class="control-group">
                <label>Angular Mapping:</label>
                <select id="angularMapping" onchange="renderAll()" style="padding: 8px; font-size: 1em;">
                    <option value="standard">Standard Counterclockwise: 2Ï€r/m</option>
                    <option value="reverse">Reverse (Clockwise): -2Ï€r/m</option>
                    <option value="complement">Complement: 2Ï€(m-r)/m</option>
                    <option value="rotated">Rotated by Ï€/2</option>
                    <option value="farey">Farey-Order Mapping</option>
                </select>
            </div>
        </div>

        <div class="zoom-controls">
            <h4>Canvas Zoom Controls</h4>
            <div class="control-group">
                <label>Unit Circle Zoom:</label>
                <input type="range" id="circleZoom" min="50" max="300" value="100" step="5" oninput="updateCircleZoom(this.value); renderUnitCircle()">
                <span class="value-display" id="circleZoomValue">100%</span>
            </div>
        </div>

        <div class="multi-canvas-grid">
            <div class="canvas-container">
                <h3 style="color: #2c3e50; margin-bottom: 15px;">Single Modulus View</h3>
                <canvas id="unitCircleCanvas" width="800" height="800"></canvas>
                <div class="export-buttons">
                    <button onclick="exportCanvas('unitCircleCanvas', '4k')">Export as 4K PNG</button>
                    <button onclick="exportCircleData()">Export Data as CSV</button>
                </div>
            </div>

            <div class="canvas-container">
                <h3 style="color: #2c3e50; margin-bottom: 15px;">Nested Modular Rings (1 to n)</h3>
                <canvas id="nestedRingsCanvas" width="800" height="800"></canvas>
                <div class="export-buttons">
                    <button onclick="exportCanvas('nestedRingsCanvas', '4k')">Export as 4K PNG</button>
                    <button onclick="exportNestedData()">Export Data as CSV</button>
                </div>
            </div>
        </div>

        <div class="controls">
            <div class="controls-header">Nested Rings Controls</div>
            <div class="control-group">
                <label>Number of Rings (n):</label>
                <input type="range" id="numRings" min="1" max="30" value="12" oninput="updateNumRings(this.value); renderNestedRings()">
                <span class="value-display" id="numRingsValue">12</span>
            </div>
            <div class="control-group">
                <label>Ring Spacing:</label>
                <input type="range" id="ringSpacing" min="0.5" max="2" value="1" step="0.1" oninput="updateRingSpacing(this.value); renderNestedRings()">
                <span class="value-display" id="ringSpacingValue">1.0</span>
            </div>
            <div class="control-group">
                <label>Color by GCD:</label>
                <input type="checkbox" id="colorByGCD" checked onchange="renderNestedRings()">
            </div>
            <div class="control-group">
                <label>Show Coprime Connections:</label>
                <input type="checkbox" id="showCoprimeConnections" onchange="renderNestedRings()">
            </div>
            <div class="control-group">
                <label>Nested Point Size:</label>
                <input type="range" id="nestedPointSize" min="1" max="8" value="2" oninput="updateNestedPointSize(this.value); renderNestedRings()">
                <span class="value-display" id="nestedPointSizeValue">2</span>
            </div>
        </div>

        <div class="zoom-controls">
            <h4>Canvas Zoom Controls</h4>
            <div class="control-group">
                <label>Nested Rings Zoom:</label>
                <input type="range" id="nestedZoom" min="50" max="300" value="100" step="5" oninput="updateNestedZoom(this.value); renderNestedRings()">
                <span class="value-display" id="nestedZoomValue">100%</span>
            </div>
        </div>

        <div class="stats-panel" id="circleStats">
            <h3>Unit Circle Statistics</h3>
            <div class="stat-item">
                <span class="stat-label">Total Points Plotted:</span>
                <span class="stat-value" id="totalPoints">0</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Coprime Points:</span>
                <span class="stat-value" id="coprimePoints">0</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Coprime Ratio:</span>
                <span class="stat-value" id="coprimeRatio">0</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Canvas Zoom Level:</span>
                <span class="stat-value" id="circleZoomStat">100%</span>
            </div>
        </div>

        <h2>2. Density of Coprime Pairs</h2>
        <div class="section-content">
            <p>Let <span class="math">A<sub>N</sub></span> = #{(<span class="math">a</span>, <span class="math">b</span>) : 1 â‰¤ <span class="math">a</span>, <span class="math">b</span> â‰¤ <span class="math">N</span>, gcd(<span class="math">a</span>, <span class="math">b</span>) = 1} be the count of coprime pairs in an <span class="math">N</span> Ã— <span class="math">N</span> grid.</p>
        </div>

        <div class="theorem">
            <div class="theorem-title">Theorem (Coprime Pair Density):</div>
            lim<sub><span class="math">N</span>â†’âˆž</sub> <span class="math">A<sub>N</sub></span> / <span class="math">N</span>Â² = 6/Ï€Â² â‰ˆ 0.6079
        </div>

        <div class="controls">
            <div class="controls-header">Coprime Pairs Controls</div>
            <div class="control-group">
                <label>Grid Size N:</label>
                <input type="range" id="gridSize" min="10" max="200" value="60" step="10" oninput="updateGridSizeDisplay(this.value); renderCoprimePairs()">
                <span class="value-display" id="gridSizeValue">60</span>
            </div>
        </div>

        <div class="zoom-controls">
            <h4>Canvas Zoom Controls</h4>
            <div class="control-group">
                <label>Coprime Pairs Zoom:</label>
                <input type="range" id="pairsZoom" min="50" max="300" value="100" step="5" oninput="updatePairsZoom(this.value); renderCoprimePairs()">
                <span class="value-display" id="pairsZoomValue">100%</span>
            </div>
        </div>

        <div class="canvas-container">
            <canvas id="coprimePairsCanvas" width="800" height="800"></canvas>
            <div class="export-buttons">
                <button onclick="exportCanvas('coprimePairsCanvas', '4k')">Export as 4K PNG</button>
                <button onclick="exportCoprimePairsData()">Export Data as CSV</button>
            </div>
        </div>

        <div class="stats-panel" id="pairsStats">
            <h3>Coprime Pairs Statistics</h3>
            <div class="stat-item">
                <span class="stat-label">Grid Size (N):</span>
                <span class="stat-value" id="pairsN">0</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Total Pairs (NÂ²):</span>
                <span class="stat-value" id="totalPairs">0</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Coprime Pairs (A<sub>N</sub>):</span>
                <span class="stat-value" id="coprimePairsCount">0</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Ratio A<sub>N</sub>/NÂ²:</span>
                <span class="stat-value" id="pairsRatio">0</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Theoretical Limit (6/Ï€Â²):</span>
                <span class="stat-value">0.607927</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Error from Limit:</span>
                <span class="stat-value" id="pairsError">0</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Canvas Zoom Level:</span>
                <span class="stat-value" id="pairsZoomStat">100%</span>
            </div>
        </div>

        <h2>3. Average Ï†(m)/m Over All Moduli</h2>
        <div class="section-content">
            <p>For each modulus <span class="math">m</span>, the ratio Ï†(<span class="math">m</span>)/<span class="math">m</span> represents the fraction of residues coprime to <span class="math">m</span>. The average of these ratios converges to the same constant 6/Ï€Â².</p>
        </div>

        <div class="theorem">
            <div class="theorem-title">Theorem (Average Totient Ratio):</div>
            lim<sub><span class="math">N</span>â†’âˆž</sub> (1/<span class="math">N</span>) Î£<sub><span class="math">m</span>=1</sub><sup><span class="math">N</span></sup> Ï†(<span class="math">m</span>)/<span class="math">m</span> = 6/Ï€Â² â‰ˆ 0.6079
        </div>

        <div class="controls">
            <div class="controls-header">Ï†(m)/m Ratio Controls</div>
            <div class="control-group">
                <label>Maximum Modulus:</label>
                <input type="range" id="phiMaxModulus" min="10" max="500" value="100" step="10" oninput="updatePhiMaxDisplay(this.value); renderPhiRatios()">
                <span class="value-display" id="phiMaxValue">100</span>
            </div>
            <div class="control-group">
                <label>Show Primes Only:</label>
                <input type="checkbox" id="primesOnly" onchange="renderPhiRatios()">
            </div>
        </div>

        <div class="zoom-controls">
            <h4>Canvas Zoom Controls</h4>
            <div class="control-group">
                <label>Ï† Ratios Zoom:</label>
                <input type="range" id="phiZoom" min="50" max="300" value="100" step="5" oninput="updatePhiZoom(this.value); renderPhiRatios()">
                <span class="value-display" id="phiZoomValue">100%</span>
            </div>
        </div>

        <div class="canvas-container">
            <canvas id="phiRatiosCanvas" width="1200" height="600"></canvas>
            <div class="export-buttons">
                <button onclick="exportCanvas('phiRatiosCanvas', '4k')">Export as 4K PNG</button>
                <button onclick="exportPhiData()">Export Data as CSV</button>
            </div>
        </div>

        <div class="stats-panel" id="phiStats">
            <h3>Totient Ratio Statistics</h3>
            <div class="stat-item">
                <span class="stat-label">Maximum Modulus:</span>
                <span class="stat-value" id="phiMaxMod">0</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Average Ï†(m)/m:</span>
                <span class="stat-value" id="avgPhiRatio">0</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Theoretical Limit (6/Ï€Â²):</span>
                <span class="stat-value">0.607927</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Error from Limit:</span>
                <span class="stat-value" id="phiError">0</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Prime Average (if checked):</span>
                <span class="stat-value" id="primeAvg">N/A</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Canvas Zoom Level:</span>
                <span class="stat-value" id="phiZoomStat">100%</span>
            </div>
        </div>

        <h2>4. Convergence Visualization</h2>
        <div class="section-content">
            <p>This chart shows how the running average of Ï†(<span class="math">m</span>)/<span class="math">m</span> converges to 6/Ï€Â² as we increase the maximum modulus. The horizontal line represents the theoretical limit.</p>
        </div>

        <div class="zoom-controls">
            <h4>Canvas Zoom Controls</h4>
            <div class="control-group">
                <label>Convergence Chart Zoom:</label>
                <input type="range" id="convergenceZoom" min="50" max="300" value="100" step="5" oninput="updateConvergenceZoom(this.value); renderConvergence()">
                <span class="value-display" id="convergenceZoomValue">100%</span>
            </div>
        </div>

        <div class="canvas-container">
            <canvas id="convergenceCanvas" width="1200" height="600"></canvas>
            <div class="export-buttons">
                <button onclick="exportCanvas('convergenceCanvas', '4k')">Export as 4K PNG</button>
                <button onclick="exportConvergenceData()">Export Data as CSV</button>
                <button class="reset-btn" onclick="resetAllZoom()">Reset All Zoom</button>
            </div>
        </div>

        <h2>5. Interpretation and Key Results</h2>
        <div class="interpretation">
            <h3>Summary of Findings:</h3>
            <ul style="margin-left: 30px; margin-top: 15px;">
                <li style="margin: 10px 0;">The set of all rational angles from roots of unity is dense on the unit circle (Theorem 1).</li>
                <li style="margin: 10px 0;">The natural density of coprime integer pairs is 6/Ï€Â² â‰ˆ 0.6079 (Theorem 2).</li>
                <li style="margin: 10px 0;">The average value of Ï†(m)/m over all moduli converges to 6/Ï€Â² (Theorem 3).</li>
                <li style="margin: 10px 0;">For prime moduli p, Ï†(p)/p = (p-1)/p â†’ 1, but primes have density zero among integers.</li>
                <li style="margin: 10px 0;">The count of reduced fractions (Farey sequence) with denominator â‰¤ N grows as (3/Ï€Â²)NÂ² + O(N log N).</li>
            </ul>
        </div>

        <div class="interpretation" style="margin-top: 30px;">
            <h3>Why There Is No Contradiction:</h3>
            <p style="margin-top: 15px;">
                Prime moduli have Ï†(p)/p â†’ 1, suggesting "almost all" residues are coprime. However, this does not contradict the global average of 6/Ï€Â² because:
            </p>
            <ul style="margin-left: 30px; margin-top: 15px;">
                <li style="margin: 10px 0;">Primes become increasingly sparse (density zero by the Prime Number Theorem).</li>
                <li style="margin: 10px 0;">Composite numbers dominate, and highly composite numbers have small Ï†(m)/m ratios.</li>
                <li style="margin: 10px 0;">The average is weighted by all integers, not just primes.</li>
            </ul>
            <p style="margin-top: 15px;">
                This phenomenon is analogous to how the average value can differ substantially from the behavior of a sparse subsequence.
            </p>
        </div>

        <footer style="margin-top: 50px; padding-top: 30px; border-top: 2px solid #333; text-align: center; color: #666;">
            <p>Interactive Research Document - 2024</p>
            <p>All results are classical theorems in analytic number theory.</p>
            <p style="margin-top: 10px;">Wessen Getachew | <a href="https://github.com/wessengetachew" style="color: #3498db;">GitHub</a> | <a href="https://twitter.com/7dview" style="color: #3498db;">@7dview</a></p>
        </footer>
    </div>

    <script>
        // Global state for zoom levels
        const zoomState = {
            circle: 1.0,
            pairs: 1.0,
            phi: 1.0,
            convergence: 1.0,
            nested: 1.0
        };

        // Nested rings state
        const nestedState = {
            numRings: 12,
            ringSpacing: 1.0,
            pointSize: 2
        };

        // Mathematical utilities
        function gcd(a, b) {
            a = Math.abs(a);
            b = Math.abs(b);
            while (b !== 0) {
                let t = b;
                b = a % b;
                a = t;
            }
            return a;
        }

        function euler_phi(n) {
            if (n === 1) return 1;
            let result = n;
            let p = 2;
            while (p * p <= n) {
                if (n % p === 0) {
                    while (n % p === 0) n /= p;
                    result -= result / p;
                }
                p++;
            }
            if (n > 1) result -= result / n;
            return Math.round(result);
        }

        function isPrime(n) {
            if (n < 2) return false;
            if (n === 2) return true;
            if (n % 2 === 0) return false;
            for (let i = 3; i * i <= n; i += 2) {
                if (n % i === 0) return false;
            }
            return true;
        }

        const SIX_OVER_PI_SQUARED = 6 / (Math.PI * Math.PI);

        // Display update functions
        function updateModulusDisplay(val) {
            document.getElementById('maxModulusValue').textContent = val;
        }

        function updatePointSizeDisplay(val) {
            document.getElementById('pointSizeValue').textContent = val;
        }

        function updateGridSizeDisplay(val) {
            document.getElementById('gridSizeValue').textContent = val;
        }

        function updatePhiMaxDisplay(val) {
            document.getElementById('phiMaxValue').textContent = val;
        }

        function updateNumRings(val) {
            nestedState.numRings = parseInt(val);
            document.getElementById('numRingsValue').textContent = val;
        }

        function updateRingSpacing(val) {
            nestedState.ringSpacing = parseFloat(val);
            document.getElementById('ringSpacingValue').textContent = parseFloat(val).toFixed(1);
        }

        function updateNestedPointSize(val) {
            nestedState.pointSize = parseInt(val);
            document.getElementById('nestedPointSizeValue').textContent = val;
        }

        function updateNestedZoom(val) {
            zoomState.nested = parseFloat(val) / 100;
            document.getElementById('nestedZoomValue').textContent = val + '%';
        }

        // Zoom update functions
        function updateCircleZoom(val) {
            zoomState.circle = parseFloat(val) / 100;
            document.getElementById('circleZoomValue').textContent = val + '%';
            document.getElementById('circleZoomStat').textContent = val + '%';
        }

        function updatePairsZoom(val) {
            zoomState.pairs = parseFloat(val) / 100;
            document.getElementById('pairsZoomValue').textContent = val + '%';
            document.getElementById('pairsZoomStat').textContent = val + '%';
        }

        function updatePhiZoom(val) {
            zoomState.phi = parseFloat(val) / 100;
            document.getElementById('phiZoomValue').textContent = val + '%';
            document.getElementById('phiZoomStat').textContent = val + '%';
        }

        function updateConvergenceZoom(val) {
            zoomState.convergence = parseFloat(val) / 100;
            document.getElementById('convergenceZoomValue').textContent = val + '%';
        }

        function resetAllZoom() {
            document.getElementById('circleZoom').value = 100;
            document.getElementById('pairsZoom').value = 100;
            document.getElementById('phiZoom').value = 100;
            document.getElementById('convergenceZoom').value = 100;
            document.getElementById('nestedZoom').value = 100;
            
            updateCircleZoom(100);
            updatePairsZoom(100);
            updatePhiZoom(100);
            updateConvergenceZoom(100);
            updateNestedZoom(100);
            
            renderAll();
        }

        // Angular mapping functions
        function getAngle(r, m, mapping, r0 = 0) {
            switch(mapping) {
                case 'standard':
                    return 2 * Math.PI * r / m;
                case 'reverse':
                    return -2 * Math.PI * r / m;
                case 'complement':
                    return 2 * Math.PI * (m - r) / m;
                case 'rotated':
                    return 2 * Math.PI * r / m - Math.PI / 2;
                case 'farey':
                    // Simplified Farey ordering by coprimality
                    const fareyIndex = getFareyIndex(r, m);
                    return 2 * Math.PI * fareyIndex / m;
                default:
                    return 2 * Math.PI * r / m;
            }
        }

        function getFareyIndex(r, m) {
            // Simple ordering: coprimes first, then non-coprimes
            let index = 0;
            for (let i = 0; i < r; i++) {
                if (gcd(i, m) === 1) index++;
            }
            return index;
        }

        // Render nested rings
        function renderNestedRings() {
            const canvas = document.getElementById('nestedRingsCanvas');
            const ctx = canvas.getContext('2d');
            const n = nestedState.numRings;
            const spacing = nestedState.ringSpacing;
            const pointSize = nestedState.pointSize;
            const colorByGCD = document.getElementById('colorByGCD').checked;
            const showConnections = document.getElementById('showCoprimeConnections').checked;
            const mapping = document.getElementById('angularMapping').value;
            const zoom = zoomState.nested;

            const cx = canvas.width / 2;
            const cy = canvas.height / 2;
            const maxRadius = (Math.min(cx, cy) - 50) * zoom;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw axes
            ctx.strokeStyle = '#ddd';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(cx - maxRadius - 20, cy);
            ctx.lineTo(cx + maxRadius + 20, cy);
            ctx.moveTo(cx, cy - maxRadius - 20);
            ctx.lineTo(cx, cy + maxRadius + 20);
            ctx.stroke();

            // Calculate ring radii
            const baseRadius = maxRadius * 0.15;
            
            // GCD color palette
            const gcdColors = {
                1: '#e74c3c',  // Coprime - red
                2: '#3498db',  // GCD 2 - blue
                3: '#2ecc71',  // GCD 3 - green
                4: '#f39c12',  // GCD 4 - orange
                5: '#9b59b6',  // GCD 5 - purple
                default: '#95a5a6'  // Other - gray
            };

            // Draw each ring
            for (let m = 1; m <= n; m++) {
                const t = (m - 1) / (n - 1 || 1);
                const radius = baseRadius + t * (maxRadius - baseRadius) * spacing;

                // Draw ring circle
                ctx.strokeStyle = 'rgba(200, 200, 200, 0.3)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(cx, cy, radius, 0, 2 * Math.PI);
                ctx.stroke();

                // Draw ring label
                ctx.fillStyle = '#666';
                ctx.font = '10px Arial';
                ctx.fillText(`m=${m}`, cx + radius + 5, cy);

                // Draw residue points
                for (let r = 0; r < m; r++) {
                    const g = gcd(r, m);
                    
                    // Get angle based on mapping
                    const angle = getAngle(r, m, mapping);
                    const x = cx + radius * Math.cos(angle);
                    const y = cy - radius * Math.sin(angle);

                    // Determine color
                    let color;
                    if (colorByGCD) {
                        color = gcdColors[g] || gcdColors.default;
                    } else {
                        color = g === 1 ? '#e74c3c' : '#95a5a6';
                    }

                    // Draw point
                    ctx.fillStyle = color;
                    ctx.beginPath();
                    ctx.arc(x, y, pointSize, 0, 2 * Math.PI);
                    ctx.fill();

                    // Draw connecting line to center for coprime points on outer ring
                    if (showConnections && m === n && g === 1 && n <= 30) {
                        ctx.strokeStyle = color;
                        ctx.lineWidth = 0.5;
                        ctx.globalAlpha = 0.3;
                        ctx.beginPath();
                        ctx.moveTo(cx, cy);
                        ctx.lineTo(x, y);
                        ctx.stroke();
                        ctx.globalAlpha = 1.0;
                    }
                }
            }

            // Draw legend
            const legendX = 20;
            const legendY = canvas.height - 120;
            
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.fillRect(legendX, legendY, 200, 100);
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            ctx.strokeRect(legendX, legendY, 200, 100);

            ctx.fillStyle = '#333';
            ctx.font = 'bold 12px Arial';
            ctx.fillText('GCD Color Legend', legendX + 10, legendY + 20);

            let y = legendY + 40;
            const legendItems = [
                { gcd: 1, label: 'GCD = 1 (Coprime)', color: gcdColors[1] },
                { gcd: 2, label: 'GCD = 2', color: gcdColors[2] },
                { gcd: 3, label: 'GCD = 3', color: gcdColors[3] },
                { gcd: 4, label: 'GCD â‰¥ 4', color: gcdColors.default }
            ];

            legendItems.forEach(item => {
                ctx.fillStyle = item.color;
                ctx.beginPath();
                ctx.arc(legendX + 15, y, 4, 0, 2 * Math.PI);
                ctx.fill();

                ctx.fillStyle = '#333';
                ctx.font = '11px Arial';
                ctx.fillText(item.label, legendX + 30, y + 4);
                y += 15;
            });

            // Angular mapping info
            ctx.fillStyle = '#2c3e50';
            ctx.font = 'bold 11px Arial';
            const mappingText = document.getElementById('angularMapping').options[
                document.getElementById('angularMapping').selectedIndex
            ].text;
            ctx.fillText('Mapping: ' + mappingText.split(':')[0], 20, 30);
        }

        function exportNestedData() {
            const n = nestedState.numRings;
            const mapping = document.getElementById('angularMapping').value;

            let csv = 'Ring_Modulus,Residue,Angle_Radians,X_Unit,Y_Unit,GCD,Is_Coprime,Mapping\n';

            for (let m = 1; m <= n; m++) {
                for (let r = 0; r < m; r++) {
                    const angle = getAngle(r, m, mapping);
                    const x = Math.cos(angle);
                    const y = Math.sin(angle);
                    const g = gcd(r, m);

                    csv += `${m},${r},${angle.toFixed(10)},${x.toFixed(10)},${y.toFixed(10)},${g},${g === 1 ? 1 : 0},${mapping}\n`;
                }
            }

            downloadCSV(csv, `nested_rings_${mapping}_data.csv`);
        }

        // Multi-canvas export selection
        function updateExportCount() {
            const count = document.querySelectorAll('.canvas-export-checkbox:checked').length;
            document.getElementById('exportCount').textContent = `${count} canvas${count !== 1 ? 'es' : ''} selected`;
        }

        function selectAllCanvasExports() {
            document.querySelectorAll('.canvas-export-checkbox').forEach(cb => cb.checked = true);
            updateExportCount();
        }

        function deselectAllCanvasExports() {
            document.querySelectorAll('.canvas-export-checkbox').forEach(cb => cb.checked = false);
            updateExportCount();
        }

        // Add event listeners to checkboxes
        document.addEventListener('DOMContentLoaded', () => {
            document.querySelectorAll('.canvas-export-checkbox').forEach(cb => {
                cb.addEventListener('change', updateExportCount);
            });
        });

        // Render Unit Circle
        function renderUnitCircle() {
            const canvas = document.getElementById('unitCircleCanvas');
            const ctx = canvas.getContext('2d');
            const maxM = parseInt(document.getElementById('maxModulus').value);
            const coprimeOnly = document.getElementById('coprimeOnly').checked;
            const pointSize = parseInt(document.getElementById('pointSize').value);
            const mapping = document.getElementById('angularMapping').value;
            const zoom = zoomState.circle;

            const cx = canvas.width / 2;
            const cy = canvas.height / 2;
            const radius = (Math.min(cx, cy) - 50) * zoom;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw circle
            ctx.strokeStyle = '#ccc';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(cx, cy, radius, 0, 2 * Math.PI);
            ctx.stroke();

            // Draw axes
            ctx.strokeStyle = '#ddd';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(cx - radius - 20, cy);
            ctx.lineTo(cx + radius + 20, cy);
            ctx.moveTo(cx, cy - radius - 20);
            ctx.lineTo(cx, cy + radius + 20);
            ctx.stroke();

            let totalPoints = 0;
            let coprimeCount = 0;
            const points = new Set();

            // Plot points
            for (let m = 1; m <= maxM; m++) {
                for (let r = 0; r < m; r++) {
                    const iscoprime = gcd(r, m) === 1;
                    if (coprimeOnly && !iscoprime) continue;

                    totalPoints++;
                    if (iscoprime) coprimeCount++;

                    const angle = getAngle(r, m, mapping);
                    const x = cx + radius * Math.cos(angle);
                    const y = cy - radius * Math.sin(angle);

                    const key = Math.round(x * 10) + ',' + Math.round(y * 10);
                    if (points.has(key)) continue;
                    points.add(key);

                    ctx.fillStyle = iscoprime ? '#e74c3c' : '#3498db';
                    ctx.beginPath();
                    ctx.arc(x, y, pointSize, 0, 2 * Math.PI);
                    ctx.fill();
                }
            }

            // Angular mapping info
            ctx.fillStyle = '#2c3e50';
            ctx.font = 'bold 14px Arial';
            const mappingText = document.getElementById('angularMapping').options[
                document.getElementById('angularMapping').selectedIndex
            ].text;
            ctx.fillText('Mapping: ' + mappingText.split(':')[0], 20, 30);

            // Update statistics
            document.getElementById('totalPoints').textContent = totalPoints;
            document.getElementById('coprimePoints').textContent = coprimeCount;
            document.getElementById('coprimeRatio').textContent = 
                totalPoints > 0 ? (coprimeCount / totalPoints).toFixed(6) : '0';
        }

        // Render Coprime Pairs Grid
        function renderCoprimePairs() {
            const canvas = document.getElementById('coprimePairsCanvas');
            const ctx = canvas.getContext('2d');
            const N = parseInt(document.getElementById('gridSize').value);
            const zoom = zoomState.pairs;

            const cellSize = (Math.min(canvas.width, canvas.height) / (N + 2)) * zoom;
            const offsetX = (canvas.width - cellSize * (N + 2)) / 2;
            const offsetY = (canvas.height - cellSize * (N + 2)) / 2;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            let coprimeCount = 0;

            for (let a = 1; a <= N; a++) {
                for (let b = 1; b <= N; b++) {
                    const x = offsetX + a * cellSize;
                    const y = canvas.height - offsetY - b * cellSize;
                    
                    if (gcd(a, b) === 1) {
                        ctx.fillStyle = '#e74c3c';
                        coprimeCount++;
                    } else {
                        ctx.fillStyle = '#ecf0f1';
                    }
                    
                    ctx.fillRect(x, y, cellSize - 1, cellSize - 1);
                }
            }

            // Draw axes
            const axisX = offsetX + cellSize;
            const axisY = canvas.height - offsetY - cellSize;
            
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(axisX, offsetY);
            ctx.lineTo(axisX, axisY);
            ctx.lineTo(canvas.width - offsetX, axisY);
            ctx.stroke();

            // Labels
            ctx.fillStyle = '#333';
            ctx.font = '16px Arial';
            ctx.fillText('a', canvas.width - offsetX - 30, axisY + 25);
            ctx.fillText('b', axisX - 30, offsetY + 20);

            // Update statistics
            const totalPairs = N * N;
            const ratio = coprimeCount / totalPairs;
            const error = Math.abs(ratio - SIX_OVER_PI_SQUARED);

            document.getElementById('pairsN').textContent = N;
            document.getElementById('totalPairs').textContent = totalPairs;
            document.getElementById('coprimePairsCount').textContent = coprimeCount;
            document.getElementById('pairsRatio').textContent = ratio.toFixed(6);
            document.getElementById('pairsError').textContent = error.toFixed(6);
        }

        // Render Phi Ratios
        function renderPhiRatios() {
            const canvas = document.getElementById('phiRatiosCanvas');
            const ctx = canvas.getContext('2d');
            const maxM = parseInt(document.getElementById('phiMaxModulus').value);
            const primesOnly = document.getElementById('primesOnly').checked;
            const zoom = zoomState.phi;

            const padding = 60;
            const plotWidth = (canvas.width - 2 * padding) * zoom;
            const plotHeight = (canvas.height - 2 * padding) * zoom;
            const offsetX = (canvas.width - plotWidth) / 2;
            const offsetY = (canvas.height - plotHeight) / 2;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw axes
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(offsetX, offsetY);
            ctx.moveTo(offsetX, canvas.height - offsetY);
            ctx.lineTo(canvas.width - offsetX, canvas.height - offsetY);
            ctx.stroke();

            // Draw theoretical limit line
            ctx.strokeStyle = '#27ae60';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            const limitY = canvas.height - offsetY - (SIX_OVER_PI_SQUARED * plotHeight);
            ctx.beginPath();
            ctx.moveTo(offsetX, limitY);
            ctx.lineTo(canvas.width - offsetX, limitY);
            ctx.stroke();
            ctx.setLineDash([]);

            // Label for limit
            ctx.fillStyle = '#27ae60';
            ctx.font = 'bold 14px Arial';
            ctx.fillText('6/Ï€Â² â‰ˆ 0.6079', canvas.width - offsetX + 10, limitY + 5);

            // Plot points
            let sum = 0;
            let count = 0;
            let primeSum = 0;
            let primeCount = 0;

            for (let m = 1; m <= maxM; m++) {
                const isPrimeNum = isPrime(m);
                if (primesOnly && !isPrimeNum) continue;

                const ratio = euler_phi(m) / m;
                const x = offsetX + (m / maxM) * plotWidth;
                const y = canvas.height - offsetY - ratio * plotHeight;

                ctx.fillStyle = isPrimeNum ? '#e74c3c' : '#3498db';
                ctx.beginPath();
                ctx.arc(x, y, 3, 0, 2 * Math.PI);
                ctx.fill();

                sum += ratio;
                count++;

                if (isPrimeNum) {
                    primeSum += ratio;
                    primeCount++;
                }
            }

            // Axes labels
            ctx.fillStyle = '#333';
            ctx.font = 'bold 16px Arial';
            ctx.fillText('Modulus m', canvas.width / 2, canvas.height - 20);
            ctx.save();
            ctx.translate(20, canvas.height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('Ï†(m)/m', 0, 0);
            ctx.restore();

            // Update statistics
            const avgRatio = sum / count;
            const error = Math.abs(avgRatio - SIX_OVER_PI_SQUARED);

            document.getElementById('phiMaxMod').textContent = maxM;
            document.getElementById('avgPhiRatio').textContent = avgRatio.toFixed(6);
            document.getElementById('phiError').textContent = error.toFixed(6);
            
            if (primeCount > 0) {
                document.getElementById('primeAvg').textContent = (primeSum / primeCount).toFixed(6);
            } else {
                document.getElementById('primeAvg').textContent = 'N/A';
            }
        }

        // Render Convergence Chart
        function renderConvergence() {
            const canvas = document.getElementById('convergenceCanvas');
            const ctx = canvas.getContext('2d');
            const maxM = 500;
            const zoom = zoomState.convergence;

            const padding = 60;
            const plotWidth = (canvas.width - 2 * padding) * zoom;
            const plotHeight = (canvas.height - 2 * padding) * zoom;
            const offsetX = (canvas.width - plotWidth) / 2;
            const offsetY = (canvas.height - plotHeight) / 2;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw axes
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(offsetX, offsetY);
            ctx.moveTo(offsetX, canvas.height - offsetY);
            ctx.lineTo(canvas.width - offsetX, canvas.height - offsetY);
            ctx.stroke();

            // Draw theoretical limit line
            ctx.strokeStyle = '#27ae60';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            const limitY = canvas.height - offsetY - (SIX_OVER_PI_SQUARED * plotHeight);
            ctx.beginPath();
            ctx.moveTo(offsetX, limitY);
            ctx.lineTo(canvas.width - offsetX, limitY);
            ctx.stroke();
            ctx.setLineDash([]);

            // Calculate running averages
            const runningAvgs = [];
            let sum = 0;
            for (let m = 1; m <= maxM; m++) {
                sum += euler_phi(m) / m;
                runningAvgs.push(sum / m);
            }

            // Plot running average
            ctx.strokeStyle = '#f39c12';
            ctx.lineWidth = 3;
            ctx.beginPath();
            for (let i = 0; i < runningAvgs.length; i++) {
                const x = offsetX + ((i + 1) / maxM) * plotWidth;
                const y = canvas.height - offsetY - runningAvgs[i] * plotHeight;
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.stroke();

            // Axes labels
            ctx.fillStyle = '#333';
            ctx.font = 'bold 16px Arial';
            ctx.fillText('Maximum Modulus N', canvas.width / 2, canvas.height - 20);
            ctx.save();
            ctx.translate(20, canvas.height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('(1/N) Î£ Ï†(m)/m', 0, 0);
            ctx.restore();

            // Legend
            ctx.fillStyle = '#27ae60';
            ctx.font = 'bold 14px Arial';
            ctx.fillText('Theoretical: 6/Ï€Â²', canvas.width - 200, offsetY + 30);
            ctx.fillStyle = '#f39c12';
            ctx.fillText('Running Average', canvas.width - 200, offsetY + 55);
        }

        // Export functions
        function exportCanvas(canvasId, resolution) {
            const canvas = document.getElementById(canvasId);
            let exportCanvas, exportCtx;

            if (resolution === '4k') {
                exportCanvas = document.createElement('canvas');
                exportCanvas.width = 3840;
                exportCanvas.height = 3840;
                exportCtx = exportCanvas.getContext('2d');
                
                const scaleX = 3840 / canvas.width;
                const scaleY = 3840 / canvas.height;
                exportCtx.scale(scaleX, scaleY);
                exportCtx.drawImage(canvas, 0, 0);
            } else {
                exportCanvas = canvas;
            }

            exportCanvas.toBlob(function(blob) {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${canvasId}_${resolution}_${Date.now()}.png`;
                a.click();
                URL.revokeObjectURL(url);
            });
        }

        // Multi-canvas export function
        function exportMultipleCanvases() {
            const selectedCheckboxes = document.querySelectorAll('.canvas-export-checkbox:checked');
            const selected = Array.from(selectedCheckboxes).map(cb => cb.value);
            
            if (selected.length === 0) {
                alert('Please select at least one canvas to export.');
                return;
            }

            document.getElementById('loading').style.display = 'block';

            setTimeout(() => {
                const resolution = document.getElementById('exportResolution').value;
                const includeLegend = document.getElementById('includeExportLegend').checked;
                const includeParameters = document.getElementById('includeExportParameters').checked;

                let width, height;
                switch(resolution) {
                    case '1080': width = 1920; height = 1080; break;
                    case '1440': width = 2560; height = 1440; break;
                    case '4k': width = 3840; height = 2160; break;
                    case '8k': width = 7680; height = 4320; break;
                }

                const canvasInfo = {
                    'circle': { canvas: document.getElementById('unitCircleCanvas'), title: 'Unit Circle', color: '#e74c3c', subtitle: 'Roots of Unity' },
                    'nested': { canvas: document.getElementById('nestedRingsCanvas'), title: 'Nested Rings', color: '#9b59b6', subtitle: 'Moduli 1 to n' },
                    'pairs': { canvas: document.getElementById('coprimePairsCanvas'), title: 'Coprime Pairs', color: '#3498db', subtitle: 'GCD Grid' },
                    'phi': { canvas: document.getElementById('phiRatiosCanvas'), title: 'Ï†(m)/m Ratios', color: '#27ae60', subtitle: 'Totient Function' },
                    'convergence': { canvas: document.getElementById('convergenceCanvas'), title: 'Convergence', color: '#f39c12', subtitle: 'Running Average' }
                };

                const count = selected.length;
                let cols, rows;
                if (count <= 2) { cols = count; rows = 1; }
                else if (count <= 4) { cols = 2; rows = 2; }
                else if (count <= 6) { cols = 3; rows = 2; }
                else { cols = 3; rows = Math.ceil(count / 3); }

                const baseSize = Math.min(width, height);
                const canvasSize = baseSize / Math.max(rows, cols);
                const legendSpace = includeLegend ? 500 : 0;
                const gridWidth = canvasSize * cols;
                const gridHeight = canvasSize * rows;

                const exportCanvas = document.createElement('canvas');
                exportCanvas.width = gridWidth + legendSpace;
                exportCanvas.height = gridHeight;
                const ctx = exportCanvas.getContext('2d');

                // Background
                ctx.fillStyle = '#0a0e27';
                ctx.fillRect(0, 0, exportCanvas.width, exportCanvas.height);

                // Draw canvases
                selected.forEach((key, idx) => {
                    const info = canvasInfo[key];
                    if (!info) return;

                    const col = idx % cols;
                    const row = Math.floor(idx / cols);
                    const x = col * canvasSize;
                    const y = row * canvasSize;

                    ctx.drawImage(info.canvas, 
                        0, 0, info.canvas.width, info.canvas.height,
                        x, y, canvasSize, canvasSize);

                    // Colored border
                    ctx.strokeStyle = info.color;
                    ctx.lineWidth = 6;
                    ctx.strokeRect(x, y, canvasSize, canvasSize);

                    // Title
                    ctx.fillStyle = info.color;
                    ctx.font = `bold ${28}px "Fira Code"`;
                    ctx.textAlign = 'center';
                    ctx.fillText(info.title, x + canvasSize / 2, y + 40);

                    // Subtitle
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                    ctx.font = `${18}px "Fira Code"`;
                    ctx.fillText(info.subtitle, x + canvasSize / 2, y + 70);
                });

                // Draw legend
                if (includeLegend) {
                    const legendX = gridWidth + 20;
                    const legendWidth = legendSpace - 40;
                    const padding = 20;

                    // Background
                    ctx.fillStyle = 'rgba(10, 14, 39, 0.95)';
                    ctx.fillRect(legendX, 20, legendWidth, gridHeight - 40);
                    ctx.strokeStyle = 'rgba(255, 215, 0, 0.5)';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(legendX, 20, legendWidth, gridHeight - 40);

                    let currentY = 60;
                    const baseFont = 22;
                    const titleFont = 28;
                    const squareSize = 24;

                    // Title
                    ctx.fillStyle = '#ffd700';
                    ctx.font = `bold ${titleFont}px "Fira Code"`;
                    ctx.textAlign = 'left';
                    ctx.fillText('LEGEND', legendX + padding, currentY);
                    currentY += titleFont * 2.5;

                    // Canvases
                    ctx.fillStyle = '#00ffff';
                    ctx.font = `bold ${baseFont * 1.2}px "Fira Code"`;
                    ctx.fillText('Visualizations', legendX + padding, currentY);
                    currentY += baseFont * 2;

                    selected.forEach(key => {
                        const info = canvasInfo[key];
                        if (!info) return;

                        // Color square
                        ctx.fillStyle = info.color;
                        ctx.fillRect(legendX + padding, currentY - squareSize * 0.8, squareSize, squareSize);
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(legendX + padding, currentY - squareSize * 0.8, squareSize, squareSize);

                        // Title
                        ctx.fillStyle = info.color;
                        ctx.font = `bold ${baseFont}px "Fira Code"`;
                        ctx.fillText(info.title, legendX + padding + squareSize + 12, currentY);

                        // Subtitle
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                        ctx.font = `${baseFont * 0.75}px "Fira Code"`;
                        ctx.fillText(info.subtitle, legendX + padding + squareSize + 12, currentY + baseFont * 1.1);

                        currentY += baseFont * 3;
                    });

                    // Parameters
                    if (includeParameters) {
                        currentY += baseFont;
                        ctx.fillStyle = '#00ffff';
                        ctx.font = `bold ${baseFont * 1.2}px "Fira Code"`;
                        ctx.fillText('Parameters', legendX + padding, currentY);
                        currentY += baseFont * 2;

                        ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                        ctx.font = `${baseFont * 0.9}px "Fira Code"`;

                        const maxM = document.getElementById('maxModulus').value;
                        const gridSize = document.getElementById('gridSize').value;
                        const phiMax = document.getElementById('phiMaxModulus').value;
                        const numRings = document.getElementById('numRings').value;
                        const mapping = document.getElementById('angularMapping').options[
                            document.getElementById('angularMapping').selectedIndex
                        ].text.split(':')[0];

                        const params = [
                            `Max Modulus: ${maxM}`,
                            `Nested Rings: ${numRings}`,
                            `Mapping: ${mapping}`,
                            `Grid Size: ${gridSize}`,
                            `Ï† Range: 1-${phiMax}`,
                            `Target: 6/Ï€Â² â‰ˆ 0.608`
                        ];

                        params.forEach(param => {
                            ctx.fillText('â€¢ ' + param, legendX + padding, currentY);
                            currentY += baseFont * 1.4;
                        });
                    }

                    // Footer
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                    ctx.font = `italic ${baseFont * 0.8}px "Fira Code"`;
                    ctx.textAlign = 'center';
                    ctx.fillText('Coprime Density Explorer', legendX + legendWidth / 2, gridHeight - 60);
                    ctx.fillText('Wessen Getachew (@7dview)', legendX + legendWidth / 2, gridHeight - 35);
                }

                // Download
                exportCanvas.toBlob(blob => {
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `Coprime_Density_${selected.length}_Canvases_${resolution}.png`;
                    a.click();
                    URL.revokeObjectURL(url);
                    
                    document.getElementById('loading').style.display = 'none';
                    alert(`Successfully exported ${selected.length} canvas${selected.length > 1 ? 'es' : ''}!`);
                });
            }, 100);
        }

        function exportCircleData() {
            const maxM = parseInt(document.getElementById('maxModulus').value);
            const coprimeOnly = document.getElementById('coprimeOnly').checked;

            let csv = 'Modulus,Residue,Angle_Radians,X_Coordinate,Y_Coordinate,Is_Coprime\n';

            for (let m = 1; m <= maxM; m++) {
                for (let r = 0; r < m; r++) {
                    const iscoprime = gcd(r, m) === 1;
                    if (coprimeOnly && !iscoprime) continue;

                    const angle = 2 * Math.PI * r / m;
                    const x = Math.cos(angle);
                    const y = Math.sin(angle);

                    csv += `${m},${r},${angle.toFixed(10)},${x.toFixed(10)},${y.toFixed(10)},${iscoprime ? 1 : 0}\n`;
                }
            }

            downloadCSV(csv, 'unit_circle_data.csv');
        }

        function exportCoprimePairsData() {
            const N = parseInt(document.getElementById('gridSize').value);

            let csv = 'a,b,gcd,is_coprime\n';

            for (let a = 1; a <= N; a++) {
                for (let b = 1; b <= N; b++) {
                    const g = gcd(a, b);
                    csv += `${a},${b},${g},${g === 1 ? 1 : 0}\n`;
                }
            }

            downloadCSV(csv, 'coprime_pairs_data.csv');
        }

        function exportPhiData() {
            const maxM = parseInt(document.getElementById('phiMaxModulus').value);

            let csv = 'Modulus,Phi_m,Ratio_Phi_m_over_m,Is_Prime\n';

            for (let m = 1; m <= maxM; m++) {
                const phi = euler_phi(m);
                const ratio = phi / m;
                const prime = isPrime(m);
                csv += `${m},${phi},${ratio.toFixed(10)},${prime ? 1 : 0}\n`;
            }

            downloadCSV(csv, 'phi_ratios_data.csv');
        }

        function exportConvergenceData() {
            const maxM = 500;

            let csv = 'N,Running_Average_Phi_over_m\n';
            let sum = 0;

            for (let m = 1; m <= maxM; m++) {
                sum += euler_phi(m) / m;
                const avg = sum / m;
                csv += `${m},${avg.toFixed(10)}\n`;
            }

            downloadCSV(csv, 'convergence_data.csv');
        }

        function downloadCSV(csv, filename) {
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
        }

        // Main render function
        function renderAll() {
            renderUnitCircle();
            renderNestedRings();
            renderCoprimePairs();
            renderPhiRatios();
            renderConvergence();
        }

        // Initialize on load
        window.onload = function() {
            renderAll();
            updateExportCount();
        };
    </script>
</body>
</html>
