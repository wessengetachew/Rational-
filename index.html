
<html>
<head>
    <title>Analytic Number Theory Visualization Framework</title>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    
    <style>
        /* --- Formal Base Styling --- */
        :root {
            --color-primary: #17202A; 
            --color-secondary: #0077B6; 
            --color-accent: #E67E22; 
            --color-background: #F8F9FA; 
            --color-control-bg: #FFFFFF;
            --color-border: #D5DBDB;
            --color-text: var(--color-primary);
            --font-family-serif: 'Georgia', 'Times New Roman', serif;
            --font-family-sans: 'Helvetica Neue', Arial, sans-serif;
        }

        /* --- Dark Mode Override --- */
        body.dark-mode {
            --color-primary: #D7DBDD; 
            --color-secondary: #4DA6FF; 
            --color-accent: #F9E79F; 
            --color-background: #1C1C1C; 
            --color-control-bg: #2C2C2C; 
            --color-border: #444444;
            --color-text: var(--color-primary);
        }
        
        html, body {
            margin: 0;
            padding: 0;
            font-family: var(--font-family-sans);
            color: var(--color-text);
            background-color: var(--color-background);
            line-height: 1.6;
            transition: background-color 0.3s, color 0.3s;
        }

        /* --- Page Structure (Adjusted for wider content) --- */
        #container {
            display: flex;
            min-height: 100vh;
            max-width: 1600px; 
            margin: 0 auto;
            box-shadow: 0 0 20px rgba(0,0,0,0.1);
        }
        
        #controls { 
            width: 380px; 
            padding: 30px; 
            background: var(--color-control-bg); 
            flex-shrink: 0;
            border-right: 1px solid var(--color-border);
            overflow-y: auto;
        }
        
        #content { 
            flex-grow: 1; 
            padding: 30px;
            display: flex;
            flex-direction: column;
        }

        /* --- Typography and Headings --- */
        #title-section {
            margin-bottom: 30px;
            padding-bottom: 10px;
            border-bottom: 2px solid var(--color-secondary);
        }
        h1 {
            font-family: var(--font-family-serif);
            color: var(--color-secondary);
            font-size: 2.8em;
            font-weight: 700;
            margin: 0 0 5px 0;
        }
        h2.subtitle {
            font-family: var(--font-family-serif);
            color: var(--color-text);
            font-size: 1.4em;
            font-weight: 400;
            font-style: italic;
            margin: 0 0 15px 0;
        }
        #abstract {
            background-color: color-mix(in srgb, var(--color-background) 80%, var(--color-border));
            padding: 20px;
            border-left: 5px solid var(--color-accent);
            border-radius: 5px;
            font-size: 0.95em;
        }
        
        h3 {
            color: var(--color-secondary); 
            font-size: 1.5em;
            font-weight: 600;
            margin-top: 30px;
            margin-bottom: 15px;
            border-bottom: 1px solid var(--color-border);
            padding-bottom: 5px;
        }
        
        /* --- Controls & Data --- */
        .control-group { 
            margin-bottom: 25px; 
            padding: 15px; 
            border: 1px solid var(--color-border); 
            border-radius: 5px;
            background-color: var(--color-control-bg);
        }
        
        label { 
            display: block; 
            margin-bottom: 8px; 
            font-weight: 600;
            color: var(--color-primary);
            font-size: 0.95em;
        }
        
        input[type=range] { accent-color: var(--color-secondary); }

        .button-group button { 
            padding: 10px 15px; 
            background-color: var(--color-secondary); 
            color: white; 
            border: none; 
            border-radius: 5px; 
            cursor: pointer;
            font-weight: 500;
            transition: background-color 0.2s;
            margin-top: 5px; /* Added spacing */
            width: 100%; /* Make buttons full width for better touch targets */
        }
        .button-group button:hover { background-color: #005A99; }
        
        .property-label { font-weight: 500; margin-top: 10px;}
        .property-value { 
            font-size: 1.1em; 
            font-weight: 700;
            color: var(--color-accent); 
        }

        /* --- Visualization Area --- */
        #visualization-area {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        #p5Canvas { 
            display: block; 
            border: 1px solid var(--color-border); 
            border-radius: 5px;
            margin-top: 20px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        
        /* Math Prose */
        #math-prose {
             max-width: 900px; /* MATCH CANVAS WIDTH */
             margin-top: 40px;
             padding: 20px;
             background-color: var(--color-control-bg);
             border-left: 5px solid var(--color-secondary);
             border-radius: 5px;
        }
        .equation-block {
            font-family: 'Courier New', monospace;
            background-color: #f0f0f0;
            padding: 10px;
            border-radius: 4px;
            overflow-x: auto;
            margin: 15px 0;
        }
        .dark-mode .equation-block {
            background-color: #333;
            color: #ddd;
        }
    </style>
</head>
<body>

<div id="container">

    <div id="controls">
        <h3><span style="color: var(--color-secondary);">I.</span> Experimental Parameters</h3>

        <div class="control-group">
            <label for="darkModeToggle">Theme Control:</label>
            <div class="button-group">
                <button id="darkModeToggle" onclick="toggleDarkMode()">Enable Dark Mode</button>
            </div>
        </div>
        
        <div class="control-group">
            <label for="visMode">Visualization Domain:</label>
            <select id="visMode" onchange="resetSketch()">
                <option value="circle">Farey Sequence Angles (Unit Circle)</option>
                <option value="lattice">Coprime Pairs Density (Lattice Plot)</option>
            </select>
        </div>

        <div class="control-group">
            <label for="limitQ">Limit Q (Maximum Denominator / Axis Extent):</label>
            <input type="range" id="limitQ" min="2" max="250" value="45" step="1" oninput="updateVisualization()">
            <span id="limitQValue" class="property-value">45</span>
            <p style="font-size: 0.85em; margin-top: 5px; color: #555;">The total number of points scales asymptotically with 6 / $\pi^2$ * Q².</p>

            <label for="pointSize">Point Size (WebGL `strokeWeight`):</label>
            <input type="range" id="pointSize" min="0.5" max="5" value="2.5" step="0.1" oninput="updateVisualization()">
        </div>

        <div class="control-group">
            <label for="colorScheme">Color Mapping Function:</label>
            <select id="colorScheme" onchange="updateVisualization()">
                <option value="denominator">By Denominator (q)</option>
                <option value="gcd_coprime">By GCD (=1 vs >1)</option>
                <option value="mobius">By Möbius mu(q)</option>
                <option value="omega">By Distinct Prime Count omega(q)</option>
                <option value="divisor_sum">By Divisor Sum sigma(q)</option>
                <option value="none">None (Uniform Color)</option>
            </select>
            
            <label for="saturation">Color Saturation (HSB):</label>
            <input type="range" id="saturation" min="50" max="100" value="80" step="1" oninput="updateVisualization()">

            <label for="brightness">Color Brightness (HSB):</label>
            <input type="range" id="brightness" min="50" max="100" value="80" step="1" oninput="updateVisualization()">
        </div>
        
        <div class="control-group">
            <h3><span style="color: var(--color-secondary);">II.</span> Computational Results (Q=<span id="propQ" class="property-value"></span>)</h3>
            
            <p class="property-label">Farey Sequence Cardinality |F_Q|:</p> 
            <strong id="propFarey" class="property-value"></strong>
            
            <p class="property-label">Count of Reduced Fractions B_Q:</p> 
            <strong id="propReducedCoprime" class="property-value"></strong>
            
            <p class="property-label">Total Coprime Pairs A_Q in [1, Q] x [1, Q]:</p> 
            <strong id="propTotalCoprime" class="property-value"></strong>
            
            <hr style="border-top: 1px dashed var(--color-border); margin: 15px 0;">
            
            <p class="property-label" style="font-weight: 600;">Asymptotic Ratio: |F_Q| / Q²</p> 
            <strong id="propRatio" class="property-value"></strong>
            <p style="font-size: 0.9em; color: #555;">Target Asymptote (3 / $\pi^2$): 0.30396</p>
        </div>

        <div class="control-group">
            <label>Image Export:</label>
            <div class="button-group">
                <button onclick="exportPNG()">Export Visualization (PNG)</button>
            </div>
        </div>
        
        <div class="control-group">
            <h3><span style="color: var(--color-secondary);">III.</span> Data Exports by Chart</h3>
            <div class="button-group">
                <button onclick="exportCSV('phi')">Export $\phi(q)$ Data (CSV)</button>
                <button onclick="exportCSV('ratio')">Export Ratio $F_Q/Q^2$ Data (CSV)</button>
                <button onclick="exportCSV('mobius')">Export Mertens $M(Q)$ Data (CSV)</button>
                <hr style="border-top: 1px dashed var(--color-border); margin: 15px 0;">
                <label>Main Data Export (Visualization Points):</label>
                <button onclick="exportCSV('main_points')">Export Main Visualization Data (CSV)</button>
            </div>
        </div>
        
    </div>
    
    <div id="content">
        
        <div id="title-section">
            <h1>The Asymptotic Density of Coprime Integers</h1>
            <h2 class="subtitle">A Visual Framework for $\zeta$(2), Farey Sequences, and Multiplicative Functions</h2>
            <div id="abstract">
                **Abstract:** This interactive tool employs a **WebGL renderer** to analyze and display the geometric distribution of coprime integer pairs (a, q) where **gcd(a, q)=1**. The visualization focuses on two domains: the **Farey sequence** mapped onto the unit circle (angles 2 * $\pi$ * a/q) and the **coprime lattice** (a x q). Computational results, including the sequence cardinality **|F_Q|** and the ratio **|F_Q| / Q²**, are provided to illustrate the convergence toward the fundamental constant **3 / $\pi^2$** = 1 / (2 * $\zeta$(2)), connecting geometric patterns to the Riemann Zeta Function. The high-performance WebGL implementation ensures stability and responsiveness for datasets containing up to millions of points.
            </div>
        </div>

        <div id="visualization-area">
             <canvas id="p5Canvas"></canvas> 
        </div>

        <div id="math-prose">
            <h3>Theoretical Background: The Constant 6 / $\pi^2$</h3>
            <p>The probability P that two positive integers selected uniformly at random are **coprime** is given by the reciprocal of the **Riemann Zeta function** evaluated at s=2.</p>
            <p>This result is derived from the **Euler product formula** for the Zeta function. The probability P is:</p>
            <div class="equation-block">
                P(gcd(a, b) = 1) = 1 / $\zeta$(2) = 1 / [ Sum from n=1 to infinity of (1 / n²) ] = 6 / $\pi^2$ $\approx$ 0.6079
            </div>
            <p>The visual framework directly explores this density: in the lattice plot, the proportion of coprime points within the Q x Q square converges to **6 / $\pi^2$**; in the unit circle plot, the cardinality of the Farey sequence **|F_Q|** grows asymptotically as **|F_Q| $\sim$ (3 / $\pi^2$) * Q²**.</p>
        </div>
    </div>
</div> <script>
    //================================================================================================
    // [JAVASCRIPT UTILITY LIBRARY: MATH AND NUMBER THEORY] 
    //================================================================================================
    
    const PI = Math.PI;
    const ZETA2_INV = 6 / (PI * PI); 
    const ZETA2_INV_HALF = ZETA2_INV / 2; 

    // Global state
    let Q_current = 45; 
    const CANVAS_W = 900; 
    const CANVAS_H = 1200; 
    
    // Adjusted plot dimensions based on new canvas width
    const PLOT_W = (CANVAS_W / 3) * 0.9;
    const PLOT_H = 350;
    
    // Adjusted start Y for 2D charts area
    const Y_DASHBOARD_AREA_P2D = 820; 
    const Y_COMPUTATIONAL_AREA_P2D = 550; // New area for computational results
    const MAIN_PLOT_Y_OFFSET = -CANVAS_H * 0.17; 
    const MAIN_PLOT_RADIUS = CANVAS_W * 0.4 / 2; 
    const MAIN_PLOT_SIZE = CANVAS_W * 0.75; 

    let dataCache = {};
    let pointSize = 2.5;
    let axisColor;
    let bgColor;
    let dashboardGraphics; 
    
    // --- Math Utilities (Functions assumed working) ---
    function gcd(a, b) { 
        if (a === 0) return b;
        while (b) { [a, b] = [b, a % b]; }
        return a;
    }
    let primes = []; let isPrimeCalculatedUpTo = 0;
    function sieve(n) {
        if (n <= isPrimeCalculatedUpTo) return;
        const is_prime = new Array(n + 1).fill(true);
        is_prime[0] = is_prime[1] = false;
        for (let p = 2; p * p <= n; p++) {
            if (is_prime[p]) {
                for (let i = p * p; i <= n; i += p) is_prime[i] = false;
            }
        }
        primes = [];
        for (let p = 2; p <= n; p++) { if (is_prime[p]) primes.push(p); }
        isPrimeCalculatedUpTo = n;
    }
    function omega(n) {
        if (n === 1) return 0;
        let count = 0; let temp = n; sieve(Math.ceil(Math.sqrt(n))); 
        for (let p of primes) {
            if (p * p > temp) break;
            if (temp % p === 0) { count++; while (temp % p === 0) temp /= p; }
        }
        if (temp > 1) count++; 
        return count;
    }
    function phi(n) {
        if (n === 0) return 0;
        let result = n; let temp = n; sieve(Math.ceil(Math.sqrt(n))); 
        for (let p of primes) {
            if (p * p > temp) break;
            if (temp % p === 0) { while (temp % p === 0) temp /= p; result -= result / p; }
        }
        if (temp > 1) result -= result / temp;
        return Math.round(result);
    }
    function mobius(n) {
        if (n === 1) return 1;
        let factors = 0; let temp = n; sieve(Math.ceil(Math.sqrt(n)));
        for (let p of primes) {
            if (p * p > temp) break;
            if (temp % p === 0) { factors++; temp /= p; if (temp % p === 0) return 0; }
        }
        if (temp > 1) factors++; 
        return (factors % 2 === 0) ? 1 : -1;
    }
    function divisorSum(n) {
        if (n === 1) return 1;
        let sum = 1; let temp = n; sieve(Math.ceil(Math.sqrt(n)));
        for (let p of primes) {
            if (p * p > temp) break;
            if (temp % p === 0) {
                let p_pow = p; let term_sum = 1;
                while (temp % p === 0) { term_sum += p_pow; p_pow *= p; temp /= p; }
                sum *= term_sum;
            }
        }
        if (temp > 1) sum *= (1 + temp);
        return sum;
    }

    // --- Data Generation ---
    function getPointsAndProperties(Q) {
        let fractions = []; let reducedCoprimeCount = 0; 
        let Q_phi_values = []; let ratio_history = []; let mobius_history = [];
        let current_F = 1; let phi_sum_ratio = 0;
        
        for (let q = 1; q <= Q; q++) {
            const phi_q = phi(q);
            current_F += phi_q;
            phi_sum_ratio += phi_q / q;
            Q_phi_values.push({ q: q, phi: phi_q });
            ratio_history.push({ q: q, ratio: current_F / (q * q) });
            mobius_history.push({ q: q, mu: mobius(q), M_q: mobius_history.length > 0 ? mobius_history[mobius_history.length - 1].M_q + mobius(q) : mobius(q) });

            for (let a = 1; a < q; a++) { 
                if (gcd(a, q) === 1) {
                    fractions.push({ a: a, q: q, value: a / q, phi: phi_q, mu: mobius(q), sigma: divisorSum(q), omega: omega(q) });
                    reducedCoprimeCount++;
                }
            }
            if (q === 1) {
                fractions.push({ a: 0, q: 1, value: 0, phi: 1, mu: 1, sigma: 1, omega: 0 });
                fractions.push({ a: 1, q: 1, value: 1, phi: 1, mu: 1, sigma: 1, omega: 0 });
            }
        }
        
        let A_Q = 0;
        sieve(Q);
        for (let d = 1; d <= Q; d++) {
            A_Q += mobius(d) * Math.floor(Q / d) * Math.floor(Q / d);
        }
        
        let latticePoints = [];
        for (let a = 1; a <= Q; a++) {
            for (let b = 1; b <= Q; b++) {
                const g = gcd(a, b);
                latticePoints.push({
                    a: a, b: b, gcd_val: g, is_coprime: (g === 1),
                    prop_value: g, mu: mobius(g), omega: omega(g), sigma: divisorSum(g),
                });
            }
        }
        
        return { fractions, latticePoints, FareyCount: current_F - 1, B_Q: reducedCoprimeCount, A_Q: A_Q, AvgPhiRatio: phi_sum_ratio / Q, Q_phi_values, ratio_history, mobius_history }; 
    }
    
    //================================================================================================
    // [P5.JS CORE: WEBGL IMPLEMENTATION] 
    //================================================================================================

    function setup() {
        let canvas = createCanvas(CANVAS_W, CANVAS_H, WEBGL); 
        canvas.id('p5Canvas'); 
        canvas.parent('visualization-area');
        colorMode(HSB, 360, 100, 100);
        noLoop(); 
        
        dashboardGraphics = createGraphics(CANVAS_W, CANVAS_H, P2D);
        dashboardGraphics.colorMode(HSB, 360, 100, 100);

        document.getElementById('limitQ').max = 250;
        document.getElementById('limitQ').value = Q_current;
        resetSketch(); 
    }
    
    function resetSketch() {
        const visMode = document.getElementById('visMode').value;
        
        if (visMode === 'circle') {
             document.getElementById('limitQ').max = 250; 
        } else {
             document.getElementById('limitQ').max = 100;
        }
        
        if (Q_current > parseInt(document.getElementById('limitQ').max)) {
            Q_current = parseInt(document.getElementById('limitQ').max);
            document.getElementById('limitQ').value = Q_current;
        }
        
        dataCache = {}; 
        updateVisualization();
    }
    
    function updateVisualization() {
        Q_current = parseInt(document.getElementById('limitQ').value);
        pointSize = parseFloat(document.getElementById('pointSize').value);

        document.getElementById('limitQValue').textContent = Q_current;
        document.getElementById('propQ').textContent = Q_current;
        
        const style = getComputedStyle(document.body);
        axisColor = color(style.getPropertyValue('--color-text'));
        bgColor = color(style.getPropertyValue('--color-control-bg'));

        if (!dataCache[Q_current]) {
            dataCache[Q_current] = getPointsAndProperties(Q_current);
        }
        
        const data = dataCache[Q_current];
        const finalRatio = data.ratio_history[data.ratio_history.length - 1].ratio;

        // Update data panel (HTML)
        document.getElementById('propFarey').textContent = data.FareyCount.toLocaleString();
        document.getElementById('propReducedCoprime').textContent = data.B_Q.toLocaleString();
        document.getElementById('propTotalCoprime').textContent = data.A_Q.toLocaleString();
        document.getElementById('propRatio').textContent = finalRatio.toFixed(6);

        redraw();
    }
    
    function draw() {
        if (!dataCache[Q_current]) return; 
        const data = dataCache[Q_current];
        const visMode = document.getElementById('visMode').value;
        
        // 1. WEBGL Setup
        clear();
        push();
        translate(0, 0, -100); 
        fill(bgColor);
        noStroke();
        plane(CANVAS_W * 2, CANVAS_H * 2); 
        pop();
        
        strokeWeight(pointSize);
        
        // 2. Draw Main Visualization
        push();
        translate(0, MAIN_PLOT_Y_OFFSET, 0); 
        
        if (visMode === 'circle') {
            drawUnitCircleWebGL(data.fractions);
        } else {
            drawCoprimeLatticeWebGL(data.latticePoints);
        }
        pop();
        
        // 3. Draw 2D UI Overlay (Title, Legend, Live Metrics, Charts)
        drawUIOverlay(dashboardGraphics, data, visMode);
        image(dashboardGraphics, -CANVAS_W/2, -CANVAS_H/2);
    }
    
    // --- COLORING LOGIC (Unchanged) ---
    function getPointColor(p, scheme, isLattice) {
        if (scheme === 'none' || (isLattice && scheme === 'gcd_coprime')) { return axisColor; }
        const sat_val = parseInt(document.getElementById('saturation').value);
        const bright_val = parseInt(document.getElementById('brightness').value);

        if (scheme === 'mobius') {
            if (p.mu === 1) return color(220, 80, 95); 
            if (p.mu === -1) return color(0, 80, 95);  
            return color(0, 0, 50); 
        }
        if (scheme === 'omega') {
            const maxOmega = Math.max(3, ...dataCache[Q_current].fractions.map(f => f.omega));
            let hue = map(p.omega, 0, maxOmega, 180, 300); 
            return color(hue, sat_val, bright_val);
        }
        let propValues = isLattice ? dataCache[Q_current].latticePoints.map(p => p.prop_value) : dataCache[Q_current].fractions.map(p => p.q);
        let minVal = Math.min(...propValues.filter(v => v > 0)); 
        let maxVal = Math.max(...propValues);
        if (maxVal === 0 || maxVal <= minVal) maxVal = minVal + 1;
        const val = isLattice ? p.prop_value : (scheme === 'divisor_sum' ? p.sigma : p.q);
        let hue = map(val, minVal, maxVal, 0, 300);
        return color(hue, sat_val, bright_val);
    }
    
    // --- VISUALIZATION DRAWING (Unchanged) ---
    function drawUnitCircleWebGL(fractions) {
        push();
        const radius = MAIN_PLOT_RADIUS; 
        
        push();
        stroke(axisColor); noFill(); strokeWeight(1);
        rotateX(PI/2); 
        torus(radius, 1, 100, 100); 
        pop();

        const scheme = document.getElementById('colorScheme').value;
        
        beginShape(POINTS);
        for (let p of fractions) {
            const angle = -2 * PI * p.value; 
            const x = radius * cos(angle);
            const z = radius * sin(angle); 
            
            stroke(getPointColor(p, scheme, false));
            vertex(x, 0, z); 
        }
        endShape();
        pop();
    }

    function drawCoprimeLatticeWebGL(latticePoints) {
        push();
        const plotSize = MAIN_PLOT_SIZE * 0.75; 
        
        translate(-plotSize/2, plotSize/2, 0); 
        
        stroke(axisColor); strokeWeight(1);
        line(0, 0, plotSize, 0); 
        line(0, 0, 0, -plotSize); 

        const scheme = document.getElementById('colorScheme').value;
        const scaleFactor = plotSize / Q_current;
        
        beginShape(POINTS);
        for (let p of latticePoints) {
            const x = p.a * scaleFactor;
            const y = -p.b * scaleFactor; 
            
            stroke(getPointColor(p, scheme, true));
            vertex(x, y, 0); 
        }
        endShape();
        pop();
    }
    
    // --- DRAW 2D UI OVERLAY ---
    function drawUIOverlay(pg, data, visMode) {
        pg.clear();
        pg.background(0, 0, 0, 0); 
        
        // 1. Title and Legend
        drawLegendAndTitleP2D(pg, visMode);

        // 2. Computational Results Display for Export
        drawLiveDataDisplayP2D(pg, data, visMode);

        // 3. Draw dashboard charts 
        pg.push(); pg.translate(10, Y_DASHBOARD_AREA_P2D); drawPhiBarChartP2D(pg, data.Q_phi_values); pg.pop();
        pg.push(); pg.translate(CANVAS_W / 2 - PLOT_W / 2, Y_DASHBOARD_AREA_P2D); drawRatioConvergenceP2D(pg, data.ratio_history); pg.pop();
        pg.push(); pg.translate(CANVAS_W - PLOT_W - 10, Y_DASHBOARD_AREA_P2D); drawMobiusSequenceP2D(pg, data.mobius_history); pg.pop();
    }
    
    function drawLegendAndTitleP2D(pg, visMode) {
        const scheme = document.getElementById('colorScheme').value;
        const Q = Q_current;
        
        // --- 1. Title ---
        pg.fill(axisColor);
        pg.textSize(28);
        pg.textAlign(CENTER, TOP);
        
        let titleText;
        if (visMode === 'circle') {
            titleText = 'Farey Sequence Angles on the Unit Circle (q \u2264 Q)'; // Unicode for <=
        } else {
            titleText = 'Coprime Pairs Density (Lattice Plot gcd(a, b)=g)';
        }
        pg.text(titleText, CANVAS_W / 2, 20);

        // --- 2. Legend Box ---
        const legendX = CANVAS_W * 0.05;
        const legendY = 60;
        const legendW = CANVAS_W * 0.9;
        const legendH = 100;

        pg.fill(bgColor);
        pg.stroke(axisColor);
        pg.rect(legendX, legendY, legendW, legendH, 5);

        pg.fill(axisColor);
        pg.textSize(14);
        pg.textAlign(LEFT, TOP);

        // Left Column (Parameters)
        pg.text(`Visualization Parameters:`, legendX + 10, legendY + 10);
        pg.textSize(16);
        pg.text(`Max Limit Q: ${Q}`, legendX + 10, legendY + 35);
        
        let pointCount = visMode === 'circle' ? dataCache[Q].FareyCount : dataCache[Q].latticePoints.length;
        pg.textSize(14);
        pg.text(`Total Points Plotted: ${pointCount.toLocaleString()}`, legendX + 10, legendY + 65);


        // Right Column (Color Scheme Details)
        pg.textSize(14);
        pg.text(`Color Map Details:`, CANVAS_W / 2 + 10, legendY + 10);
        pg.textSize(16);
        pg.text(`Scheme: ${document.getElementById('colorScheme').options[document.getElementById('colorScheme').selectedIndex].text}`, CANVAS_W / 2 + 10, legendY + 35);
        
        let colorRangeText = `Range: Varies by selected function (q: 1 to ${Q})`;
        if (scheme === 'gcd_coprime') {
            colorRangeText = 'Range: Coprime (V=1) vs. Not Coprime (V>1)';
        } else if (scheme === 'mobius') {
            colorRangeText = 'Range: Mu(q) = 1, -1, or 0';
        }
        pg.textSize(14);
        pg.text(colorRangeText, CANVAS_W / 2 + 10, legendY + 65);
    }

    // Corrected with Unicode for Export
    function drawLiveDataDisplayP2D(pg, data, visMode) {
        const x = CANVAS_W * 0.05;
        const y = Y_COMPUTATIONAL_AREA_P2D; 
        const w = CANVAS_W * 0.9;
        const h = 75;
        const colW = w / 4;
        
        pg.fill(bgColor);
        pg.stroke(axisColor);
        pg.rect(x, y, w, h, 5);
        
        pg.fill(axisColor);
        pg.textSize(14);
        pg.textAlign(CENTER, TOP);

        // --- Box 1: Farey Sequence Cardinality |F_Q| ---
        pg.textStyle(BOLD);
        pg.text(`Farey Sequence |F\u208B${Q_current}\u208C|:`, x + colW/2, y + 10); // \u208B and \u208C are subscript brackets
        pg.textStyle(NORMAL);
        pg.fill(color('#E67E22'));
        pg.text(data.FareyCount.toLocaleString(), x + colW/2, y + 35);
        pg.fill(axisColor);

        // --- Box 2: Count of Reduced Fractions B_Q ---
        pg.textStyle(BOLD);
        pg.text(`Reduced Fractions B\u208B${Q_current}\u208C:`, x + colW*1.5, y + 10);
        pg.textStyle(NORMAL);
        pg.fill(color('#0077B6'));
        pg.text(data.B_Q.toLocaleString(), x + colW*1.5, y + 35);
        pg.fill(axisColor);

        // --- Box 3: Total Coprime Pairs A_Q ---
        pg.textStyle(BOLD);
        pg.text(`Coprime Pairs A\u208B${Q_current}\u208C:`, x + colW*2.5, y + 10);
        pg.textStyle(NORMAL);
        pg.fill(color('#9B59B6'));
        pg.text(data.A_Q.toLocaleString(), x + colW*2.5, y + 35);
        pg.fill(axisColor);

        // --- Box 4: Asymptotic Ratio |F_Q| / Q² ---
        pg.textStyle(BOLD);
        pg.text(`Ratio |F\u208B${Q_current}\u208C| / Q\u00B2:`, x + colW*3.5, y + 10); // \u00B2 is superscript 2
        pg.textStyle(NORMAL);
        pg.fill(color('#2ECC71'));
        pg.text(data.ratio_history[data.ratio_history.length - 1].ratio.toFixed(6), x + colW*3.5, y + 35);
        pg.fill(axisColor);
        pg.textSize(10);
        // Use \u03C0 for pi
        pg.text(`Target: 3 / \u03C0\u00B2 \u2248 ${ZETA2_INV_HALF.toFixed(6)}`, x + colW*3.5, y + 55); 

        // Draw vertical separators
        pg.stroke(axisColor);
        pg.line(x + colW, y + 5, x + colW, y + h - 5);
        pg.line(x + colW*2, y + 5, x + colW*2, y + h - 5);
        pg.line(x + colW*3, y + 5, x + colW*3, y + h - 5);
    }
    
    // --- CHART DRAWING FUNCTIONS (Positions relative to Y_DASHBOARD_AREA_P2D) ---
    
    function drawPhiBarChartP2D(pg, phiData) {
        const chartW = PLOT_W; const chartH = PLOT_H; const margin = 30;
        pg.noFill(); pg.stroke(axisColor); pg.rect(0, 0, chartW, chartH);
        
        const maxPhi = Math.max(...phiData.map(d => d.phi), 1);
        const plotAreaH = chartH - margin * 2;
        const barW = chartW / Q_current;
        
        pg.stroke(axisColor); pg.line(0, chartH - margin, chartW, chartH - margin); 
        pg.push(); pg.translate(0, chartH - margin);
        
        for (let i = 0; i < phiData.length; i++) {
            const data = phiData[i];
            const barHeight = map(data.phi, 0, maxPhi, 0, plotAreaH);
            let hue = map(data.phi / data.q, 0, 1, 30, 100); 
            pg.fill(hue, 80, 80); pg.noStroke();
            pg.rect(i * barW, 0, barW * 0.9, -barHeight);
        }
        pg.pop();
        
        // Title for the chart: Replaced \phi with \u03C6
        pg.fill(axisColor);
        pg.textSize(14);
        pg.textAlign(CENTER, TOP);
        pg.text("Euler's Totient \u03C6(q) Distribution", chartW / 2, 5); 
    }
    
    function drawRatioConvergenceP2D(pg, ratioHistory) {
        const chartW = PLOT_W; const chartH = PLOT_H; const margin = 30;
        pg.noFill(); pg.stroke(axisColor); pg.rect(0, 0, chartW, chartH);
        
        const minY = 0.28; const maxY = Math.max(...ratioHistory.map(d => d.ratio), 0.5);
        const asymptoticY = map(ZETA2_INV_HALF, minY, maxY, chartH - margin, margin); 
        
        // Asymptotic Line
        pg.stroke(color('#E67E22')); pg.strokeWeight(2);
        pg.line(0, asymptoticY, chartW, asymptoticY);
        pg.fill(axisColor); pg.textSize(10); pg.textAlign(RIGHT, CENTER);
        // Replaced \pi^2 with \u03C0\u00B2
        pg.text(`Target ${ZETA2_INV_HALF.toFixed(4)}`, chartW - 5, asymptoticY);

        // Data Line
        pg.noFill(); pg.stroke(color('#0077B6')); pg.strokeWeight(2); 
        
        pg.beginShape();
        for (let i = 0; i < ratioHistory.length; i++) {
            const data = ratioHistory[i];
            const x = map(data.q, 1, Q_current, 0, chartW);
            const y = map(data.ratio, minY, maxY, chartH - margin, margin);
            pg.vertex(x, y);
        }
        pg.endShape();
        
        // Title for the chart: Replaced \pi^2 and Q^2 with \u03C0\u00B2 and Q\u00B2
        pg.fill(axisColor);
        pg.textSize(14);
        pg.textAlign(CENTER, TOP);
        pg.text("Ratio Convergence: |F\u208BQ\u208C| / Q\u00B2 \u2192 3 / \u03C0\u00B2", chartW / 2, 5); // \u2192 is right arrow
    }
    
    function drawMobiusSequenceP2D(pg, mobiusData) {
        const chartW = PLOT_W; const chartH = PLOT_H; const margin = 30;
        const plotAreaH = chartH - margin * 2;
        const midpointY = chartH - margin - plotAreaH / 2;

        pg.noFill(); pg.stroke(axisColor); pg.rect(0, 0, chartW, chartH);
        pg.stroke(axisColor); pg.line(0, midpointY, chartW, midpointY);
        
        const pointDiameter = 4;
        
        for (let i = 0; i < mobiusData.length; i++) {
            const data = mobiusData[i];
            const x = map(data.q, 1, Q_current, 0, chartW);
            let y;
            
            // Plot mu(q) points
            if (data.mu === 1) { y = midpointY - plotAreaH / 2; pg.fill(220, 80, 95); } 
            else if (data.mu === -1) { y = midpointY + plotAreaH / 2; pg.fill(0, 80, 95); } 
            else { y = midpointY; pg.fill(0, 0, 50); }
            
            pg.noStroke();
            pg.ellipse(x, y, pointDiameter, pointDiameter);
            
            // Plot M(Q) summation
            const M_y = map(data.M_q, -Q_current / 2, Q_current / 2, midpointY + plotAreaH / 2, midpointY - plotAreaH / 2);
            pg.stroke(60, 80, 80); 
            if (i > 0) {
                const prevX = map(mobiusData[i-1].q, 1, Q_current, 0, chartW);
                const prevM_y = map(mobiusData[i-1].M_q, -Q_current / 2, Q_current / 2, midpointY + plotAreaH / 2, midpointY - plotAreaH / 2);
                pg.line(prevX, prevM_y, x, M_y);
            }
        }
        
        // Title for the chart: Replaced \Sigma and \mu(q) with \u03A3 and \u03BC(q)
        pg.fill(axisColor);
        pg.textSize(14);
        pg.textAlign(CENTER, TOP);
        pg.text("Mertens Function M(Q) = \u03A3\u03BC(q)", chartW / 2, 5); 
    }
    
    // --- UI Control and Export Functions ---
    function toggleDarkMode() {
        const isDarkMode = document.body.classList.toggle('dark-mode');
        document.getElementById('darkModeToggle').textContent = isDarkMode ? 'Disable Dark Mode' : 'Enable Dark Mode';
        updateVisualization();
    }
    
    function exportPNG() { 
        const visMode = document.getElementById('visMode').value;
        const filename = visMode + '_Q' + Q_current + '_Export_WithResults.png';
        saveCanvas(filename, 'png'); 
    }
    
    // **MODIFIED: Now accepts a dataType argument to export specific data sets.**
    function exportCSV(dataType) { 
        const data = dataCache[Q_current];
        let csvContent = "";
        let filename = "Data_Q" + Q_current;
        const visMode = document.getElementById('visMode').value;

        if (!data) {
            alert("Please calculate data first by setting Q.");
            return;
        }

        if (dataType === 'main_points') {
            if (visMode === 'circle') {
                csvContent = "q,a,Fraction_Value,Angle_Radians,Phi_q,Mu_q,Sigma_q\n";
                for (let p of data.fractions) {
                    csvContent += `${p.q},${p.a},${p.value.toFixed(8)},${(p.value * 2 * PI).toFixed(6)},${p.phi},${p.mu},${p.sigma}\n`;
                }
                filename = "Farey_Angles_Q" + Q_current + ".csv";
            } else {
                csvContent = "a,b,GCD_Value,Is_Coprime,Mu_gcd,Sigma_gcd\n";
                for (let p of data.latticePoints) {
                    csvContent += `${p.a},${p.b},${p.gcd_val},${p.is_coprime ? 'TRUE' : 'FALSE'},${p.mu},${p.sigma}\n`;
                }
                filename = "Coprime_Lattice_Q" + Q_current + ".csv";
            }
        } else if (dataType === 'phi') {
            csvContent = "q,Euler_Phi_q\n";
            for (let d of data.Q_phi_values) {
                csvContent += `${d.q},${d.phi}\n`;
            }
            filename = "Totient_Function_Q" + Q_current + ".csv";
        } else if (dataType === 'ratio') {
            csvContent = "Q,Farey_Count_FQ,Ratio_FQ_div_Q2\n";
            for (let d of data.ratio_history) {
                const FQ = (d.q > 0 && d.q <= data.ratio_history.length) ? data.ratio_history[d.q - 1].q * data.ratio_history[d.q - 1].ratio * d.q : 'N/A';
                csvContent += `${d.q},${(d.q * d.q * d.ratio).toFixed(0)},${d.ratio.toFixed(8)}\n`;
            }
            filename = "Ratio_Convergence_Q" + Q_current + ".csv";
        } else if (dataType === 'mobius') {
            csvContent = "q,Mobius_Mu_q,Mertens_MQ\n";
            for (let d of data.mobius_history) {
                csvContent += `${d.q},${d.mu},${d.M_q}\n`;
            }
            filename = "Mertens_Function_Q" + Q_current + ".csv";
        } else {
            alert("Invalid data type specified for export.");
            return;
        }

        let encodedUri = "data:text/csv;charset=utf-8," + encodeURIComponent(csvContent);
        let link = document.createElement("a");
        link.setAttribute("href", encodedUri);
        link.setAttribute("download", filename);
        document.body.appendChild(link); 
        link.click();
        document.body.removeChild(link);
    }
</script>
</body>
</html>
